<h1>Fab: Python Model/Fabrication w/FreeCAD.</h1>
<h2>Table of Contents:</h2>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#overview">Overview</a></li>
<li><a href="#python-modules">Python Modules</a></li>
<li><a href="#additional-documentation">Addtional Documentation</a></li>
<li><a href="#installation">Installation</a></li>
</ul>
<h2>Introduction <a name="introduction"></a></h2>
<p>The Fab package is a FreeCAD focused Python library that supports a DFM workflow where:</p>
<ul>
<li>FreeCAD is an open source CAD/CAM (Computer Aided Design/Manufacturing) application,</li>
<li>Python is rather popular programming language, and</li>
<li>DFM stands for Design For Manufacture.
The Fab Python package aids the process of transforming an idea int a design and eventually
into finalized physical object.</li>
</ul>
<p>In Fab, each individual part conceptually starts with some stock material followed by operations
performed on the stock material (e.g. contour outlines, drill holes, remove pockets, etc.)
All of the individual parts are assembled into a final assembly which can be viewed
using FreeCAD.</p>
<p>Fab supports the concept of multiple different shops, where the specific shop machines
and tooling are specified.
The Fab design in conjunction with a the Fab shop specification generates the various files
(<code>.cnc</code>, <code>.stl</code>, <code>.dxf</code>, etc.) needed to manufacture the part for a specific shop.
Thus, one Fab design can be shared among multiple people with different shops and
still get basically the same physical objects.</p>
<h2>Overview <a name="overview"></a></h2>
<p>The Fab strategy is to construct nested tree of FabNode's, where a FabNode is the primitive
base class and roughly (but not exactly) corresponds to an object in the FreeCAD object tree.
There are various sub-classes of FabNode -- FabGeometry, FabOperation, FabSolid,
FabAssembly, FabFile, and FabRoot, where FabRoot is the root of the FabNode tree.</p>
<p>The FabNode tree is constructed in a bottom up fashion:</p>
<ol>
<li>Various lengths and angles are defined.</li>
<li>3D points, called Vectors's, are defined using the various lengths and angles.</li>
<li>Subsets of the Vectors's are projected onto a 2D plane to form lines, arcs, and circles
which are then converted to form a 2D drawing which based the FreeCAD Draft workbench.
The 2D geometry is the FabGeometry.</li>
<li>These drawings are converted into solid geometry using the some additional FabNode's
(called FabOperation's) that basically schedule the FreeCAD PartDesign workbench to
perform using a variety of 3D operations (e.g. extrude, pocket, drill, etc.) resulting
in a FabSolid.</li>
<li>The various parts are configured into assemblies (FabAssembly) and FreeCAD <code>.FCstd</code> files
(ModeFabFile) are stored in the root of the tree (FabRoot).</li>
</ol>
<p>Once the FabRoot is present there are 4 phases performed:</p>
<ol>
<li>The FabRoot is iterated in configuration mode whereby constraints are propagated through
out the Fab tree.  Sometimes there is a constraint loop, which is detected and reported
as a failure that needs to get fixed.</li>
<li>The FabRoot is iterated over to construct the 3D model which can be viewed using FreeCAD.</li>
<li>When the design looks good, all of the manufacturing files are generated
(e.g. .nc, .stl, .dxf files.)</li>
<li>The manufacturing files are used to fabricate the individual parts which are
then assembled into the final assembly.</li>
</ol>
<h2>Python Modules <a name="python-modules"></a></h2>
<p>The basic Python bottom up Python module list is:</p>
<ul>
<li><a href="Utilities.html">Utilities</a>:
Utilities module of miscellaneous classes -- Bounding Box, Colors, Materials, etc.</li>
<li><a href="Tree.html">Tree</a>:
This defines the basic FabNode classes.</li>
<li><a href="Geometry.html">Geometry</a>:
The defines the 2D geometry FabNode classes for using the FreeCAD Draft workbench.</li>
<li><a href="Solid.html">Solid</a>:
A library that supports generating parts using the FreeCAD PartDesign workbench.</li>
<li><a href="Shop.html">Shop</a>:
A library that defines machines and tooling available in a given shop.</li>
<li><a href="CNC.html">CNC</a>:
A library that interfaces with the FreeCAD Path workbench for producing CNC files.</li>
</ul>
<h2>Type Hints and Data Classes</h2>
<p>If you are completely unfamiliar with Python Type hints, please see the following references:</p>
<ul>
<li><a href="http://mypy-lang.org/">mypy</a></li>
<li><a href="https://docs.python.org/3/library/typing.html"><code>typing</code> -- Support for type hints</a></li>
</ul>
<p>While the underlying FreeCAD Python support currently does not support Python type hints,
the Fab Python package is heavily annotated with Python Type Hints.
What this means is that if you write your Python code that uses the Fab package using type hints,
you can frequently uncover errors via before execution using static analysis with the
<code>mypy</code> program.</p>
<p>In addition, all Fab Package classes are done using Python data classes (see immediately below).
Python data classes which <em><strong>require</strong></em> type hints.
Since the way the Fab package requires that you that you sub-class from Fab package classes,
its necessary to learn more about both topics.</p>
<p>The reference documentation of <a href="https://docs.python.org/3/library/dataclasses.html">Data Classes</a>
is actually quite dense and difficult to understand.
The readily available free tutorials are good,
but tend to be introductory without getting into important details.
This section attempts to delve into the data class issues that are important for the Fab package.</p>
<p>A basic usage of data classes is:</p>
<pre><code> # Import the `dataclass` &quot;decorator&quot; from the `dataclasses` package.
 from dataclasses import dataclass, field

 # Define the dataclass:
 @dataclass  # Decorator that specifies class is a data class
 class ClassName(SubClass):  # The `class` definition with associated SubClass
     '''Python class documentation string goes here.'''

     FieldName1: Type1   # There ***MUST*** be at least one field defined.
     FieldName2: Type2
     # ...
     FieldNameN: TypeN

     def __post_init__(self) -&gt; None:
         '''Python method documentation string goes here.'''
         super().__post_init__()  # For sub-class only.  Not needed for a base class.

         # Additional initialization code goes here.
</code></pre>
<p>The key thing is that it is a Python class definition with a preceding <code>@dataclass</code> decorator.
There are one or more field names followed by a colon and a type hint.
What the class decorator does is generate both an <code>__init__()</code> method and a <code>__repr__()</code>.</p>
<p>The field names are defined in one of three ways:</p>
<pre><code>    Required: Type
    Optional: Type = InitialValue
    Private: Type = field(init=False, ...)
</code></pre>
<p>All required and optional fields show up in the generated <code>__init__()</code> method.
None of the private fields show up in the <code>__init__()</code> method.</p>
<p>Understanding the <code>__init__</code> method construction is <em>very</em> important.
The order that fields show up in the <code>__init__()</code> method depends on sub-classing.
Look at the following contrived example:</p>
<pre><code> @dataclass
 class BaseClass(object):
    BR1: BRT1  # Base Required 1
    BR2: BRT2  # Base Required 2
    BO1: BOT1 = BV1  # Base Optional 1
    BO2: BOT2 = BV2  # Base Optional 2
    BP1: BPT1 = field(init=False)  # Base Private 1
    BP2: BPT2 = field(init=False)  # Base Private 2

 @dataclass
 class SubClass(object):
    SR1: SRT1  # Base required type
    SR2: SRT2  # Base required type
    SO1: SOT1 = SV1 # Base optional type
    SO2: SOT2 = SV2  # Base optional type
    SP1: SPT1 = field(init=False)
    SP2: SPT2 = field(init=False)
</code></pre>
<p>The generated <code>__init__()</code> method for BassClass is:</p>
<pre><code> def __init__(BR1: BRT1, BR2: BRT2, BO1: BOT1 = BV1, BO2: BPT2 = BV2) -&gt; None:
    ...
</code></pre>
<p>The generated <code>__init__()</code> method for SubClass is:</p>
<pre><code> def __init__(BR1: BRT1, BR2: BRT2, BO1: BOT1 = BV1, BO2: BOT2 = BV2,
              SR1: SRT1, SR2: SRT2, SO1: SOT1 = SV1, SO2: SOT2 = BV2) -&gt; None:
     # ...
</code></pre>
<p>Notice that all of the required arguments are sorted first, followed by the optional arguments.
None of the private fields show up in the <strong>init</strong>() method.</p>
<p>Next, the <strong>repr</strong>() method needs discussion.  In general, every field will show up
in the <strong>repr</strong>() method unless it is explicitly disabled.  The way to disable the
the field in <strong>repr</strong>() is as follows:</p>
<pre><code>RequiredField: RequiredType = field(init=False)
OptionalField: OptionalType = field(init=False, default=OptionalValue)
PrivateField: PrivateType = field(init=False, repr=False)
</code></pre>
<p>By common convention, classes, methods, and fields that start with an underscore ('_')
are considered to be private and only the &quot;owner&quot; should access these fields.
While other languages enforce private fields, Python does not.
The preceding underscore convention is widely adhered to through out large bodies of Python code.</p>
<p>Sometime it is desirable to provide read only access to field.
The preferred way to solve this problem is to use a python property.
(See <a href="https://pythonguide.readthedocs.io/en/latest/python/property.html">Methods and @propert)</a>
for more detail.</p>
<p>In short a private field can provide a public read-only access as follows:</p>
<pre><code> @dataclass
 class MyClass(object):
     '''MyClass documentation string.'''

     _Field: FieldType   # Internal field declaration

    # Accessor function for
    @property
    def Field(self) -&gt; FieldType:
        '''Field documentation string.'''
        return self._Field
</code></pre>
<p>It should be noted that many of the most common FreeCAD base types
(e.g. Vector, Rotation, Placement, etc.) are <em>mutable</em>, where mutable means that
the contents can be changed.
Usually, people like to treat these classes as if they are immutable.
It is extremely copy to have accessor functions that return a copy of a private field.
For the FreeCAD Vector class, the easiest way to make a copy is as follows:</p>
<pre><code> @property
 def Normal(self) -&gt; Vector:
     '''Return the Normal to the object.'''
     copy: Vector = Vector()  # Returns Vector(0, 0, 0)
     return self._Normal + copy  # Returns a copy of self._Normal.
</code></pre>
<p>Likewise when mutable object is passed into dataclass, it is frequently desirable to
make a private copy.  This can be done in <strong>post_init</strong>():</p>
<pre><code>     @dataclass
     class LineSegment(object):
         '''LineSegment document string goes here.'''

         _Point1: Vector
         _Point2: Vector
         _copy: Vector = field(init=False, repr=False)

         def __post_init__(self) -&gt; self:
             '''Document string goes here.'''
             self._copy: Vector = Vector()
             self._Point1 += copy  # Force copy into _Point1
             self._Point2 += copy  # Force copy into _Point2

         @property
         def Point1(self) -&gt; Vector:
             '''Document string goes here.'''
             return self._Point1 + self._copy  # Return copy of _Point1

         @property
         def Point2(self) -&gt; Vector:
             '''Document string goes here.'''
             return self._Point2 + self._copy  # Return copy of _Point2
</code></pre>
<p>Usage of the class above would be like:</p>
<pre><code> point1: Vector = Vector(1, 2, 3)
 point2: Vector = Vector(4, 5, 6)
 line_segment: LineSegment = LineSegment(point1, point2)
 # Copies *point1* and *point2* are stored in *line_segment*.
 assert point1 == Vector(1, 2, 3)
 normal: Vector = point1.normalize()  # This method modifies point
 assert point1 != Vector(1, 2, 3)  # *point1* got changed!
 assert line_segment.Point1 == Vector(1, 2, 3)  # Original copy is returned.
 # Modifies the returned copy, but the private copy is safe.
 assert line_segment.Point1.normalize() != Vector(1, 2, 3)
 assert line_segment.Point1 == Vector(1, 2, 3)
</code></pre>
<p>It would be nice if the FreeCAD Vector class were not mutable, but since it is nota,
extra care is the prudent way to avoid accidental mutations of internal values.</p>
<h2>Additional documentation <a name="additional-documentation"></a></h2>
<p>There are some additional miscellaneous Python modules:</p>
<ul>
<li><a href="docs/Doc.html">Doc</a>:
A documentation extraction utility that reads the Python documentation strings and
generates both markdown and HTML documentation files.</li>
<li><a href="embedded_freecad.html">Embedded FreeCAD</a>:
This explains how the Fab modules can be run within or externally from FreeCAD.</li>
<li><a href="fcstd_tar_sync.html">fcstd_tar_sync.py</a>]:
A program that mirrors FreeCAD <code>.fcstd</code> files to <code>.tar</code> files that are more easily stored
under the <code>git</code> revision control system.</li>
<li><a href="coding_documentation.html">Coding/Documentation/Testing</a>:
The coding, documentation, and testing standards uses for code in</li>
<li><a href="LICENSE.md">LICENSE.md</a>: The Open Source license for the Model source files.</li>
</ul>
<h2>Installation <a name="installation"></a></h2>
<p>These installation instructions are currently focused towards the Ubuntu 20.04 Linux distribution.</p>
<ul>
<li>
<p>Install the <code>build-essential</code> and <code>git</code> packages:</p>
<p>sudo apt install build-essential git</p>
</li>
<li>
<p>Clone the Fab git repository:</p>
<p>mkdir -p ~/downloads  # or where you like to download git repositories.
cd ~/downloads
git clone ...  # (TBD)</p>
</li>
<li>
<p>Run <code>make install</code>:</p>
<p>make install</p>
</li>
</ul>
