<h1>Fab: Python Modeling and Fabrication.</h1>
<h2>Table of Contents:</h2>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#workflow">Workflow</a></li>
<li><a href="#python-modules">Python Modules</a></li>
<li><a href="#additional-documentation">Addtional Documentation</a></li>
<li><a href="#installation">Installation</a></li>
</ul>
<h2>Introduction <!-- raw HTML omitted --><!-- raw HTML omitted --></h2>
<p>The Fab package is a FreeCAD/CadQuery focused Python library that supports a DFM workflow where:</p>
<ul>
<li>FreeCAD/CadQuery are an open source CAD/CAM (Computer Aided Design/Manufacturing) applications,</li>
<li>Python is rather popular programming language, and</li>
<li>DFM stands for Design For Manufacture.
The Fab Python package aids the process of transforming an idea into a design and eventually
into finalized physical object.</li>
</ul>
<p>In Fab, each individual part conceptually starts with some stock material followed by operations
performed on the stock material (e.g. contour outlines, drill holes, remove pockets, etc.)
All of the individual parts are assembled into a final assembly which can be viewed using FreeCAD.</p>
<p>Fab supports the concept of multiple different shops,
where the specific machines and associated tooling within each shop are specified.
The Fab design in conjunction with a the Fab shop specification generates the various files
(<code>.cnc</code>, <code>.stl</code>, <code>.dxf</code>, etc.) needed to manufacture the part for a specific shop.
Thus, one Fab design can be shared among multiple people with different shops and
still get basically the same physical objects.</p>
<h2>Overview <!-- raw HTML omitted --><!-- raw HTML omitted --></h2>
<p>The abbreviations NIY (Not Implemented Yet) and WIP (Work In Progress) are used
to indicate current development status.</p>
<p>The way Fab works is as follows:</p>
<ol>
<li>
<p>(WIP)
You write one or more Python design modules (e.g. <code>.py</code> files) that defines of all of the parts
you wish to buy/create and how they are assembled together.
Simple projects can be in one Python module,
but more complex projects will span multiple Python modules (e.g. a Python package.)
These python modules are written to use generic mills, lathes, laser cutters, 3D printers, etc.
These designs are meant to parametric in that somebody can change dimensions, materials, etc.</p>
</li>
<li>
<p>(WIP)
You may have access to multiple shops (e.g your home shop, a maker space, etc.)
For each shop, somebody writes a Python module that describes the shop machines
(e.g. 3D printers, laser cutters, mills, lathes, etc.)
and any associated machine tooling (e.g. mill bits, lathe cutters, etc.)</p>
</li>
<li>
<p>(NIY)
A Python module is written that does the following:</p>
<ol>
<li>
<p>Imports a collection of design files (step 1) and shops (step 2).</p>
</li>
<li>
<p>Parametric values are specified (e.g. lengths, angle, materials, etc.)</p>
</li>
<li>
<p>Specific shop machines are can be bound to specific parts.
This will cause the correct output for each part to be generated
(e.g. <code>.stl</code>, <code>.dxf</code>, <code>.cnc</code> files.)</p>
</li>
</ol>
<p>In order, to keep this Python module small,
defaults are used to simplify the shop machine to part binding process.</p>
</li>
</ol>
<p>Using this architecture, the result is shareable parametric designs that fabricated
using different shops and still get basically the same result.</p>
<h2>Commonly Used Fab Classes <!-- raw HTML omitted --><!-- raw HTML omitted --></h2>
<p>Each Fab project is implemented as one or more Python files that import Fab package classes.
(As a side note, each user facing Fab class is always prefixed with <code>Fab</code>.)</p>
<p>The Fab strategy is to construct nested tree of FabNode's,
where a FabNode is a base class that sub-classed to provide additional structure.
The sub-classes are:</p>
<ol>
<li>
<p>FabProject: This is the top level FabNode that encapsulates your entire project.</p>
</li>
<li>
<p>FabDocument: This corresponds to a FreeCAD document file (i.e. <code>.FCStd</code>).</p>
</li>
<li>
<p>FabAssembly: This a group of smaller FabAssembly's and FabSolid's.</p>
</li>
<li>
<p>FabSolid: This corresponds to a single Solid object
that can be represented as CAD industry standard file interchange format call a STEP file.</p>
</li>
</ol>
<p>There is one FabProject at the tree root, typically almost always just one FabDocument,
followed nested as series of zero, one or more FabAssembly's,
with the leaf nodes all being FabSolid's.</p>
<p>An example decomposition is shown immediately below:</p>
<ul>
<li>FabProject (root)
<ul>
<li>FabDocument (usually only one of these)
<ul>
<li>FabAssembly 1 (usually there is just one top level FabAssembly just under the Fab Document)
<ul>
<li>FabSolid 1</li>
<li>FabAssembly 2
<ul>
<li>FabSolid 2</li>
<li>FabSolid 3</li>
</ul>
</li>
<li>FabSolid 4</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>In addition, there is a FabGeometry base class that currently provides the following sub-classes
which are assembled using Vector's (i.e. points) and dimensions (i.e. floats):</p>
<ul>
<li>
<p>FabPolygon:
This is defined as a sequence of Vector's that that define a loop of line segments in 3D space.
In practice, these line segments are always projected onto plane in 3D space before being used.
Each polygon corner has an optional rounding radius for filleting purposes.</p>
</li>
<li>
<p>FabCircle: This defines a sphere of a known diameter/radius centered around a Vector (point).
Again, this sphere is projected onto a plane to generate a circle in 3D space.</p>
</li>
</ul>
<p>These FabGeoemtry objects are used by the FabSolid methods to generate 3D solids.</p>
<p>A FabSolid is produced in a very CNC (Computer Numerical Control) fashion using a sequence of
one or more mounts (called FabMount's) and performing operations on each FabMount.
The FabMount class specifies a work plane in 3D space (this essentially a CadQuery Workplane.)
Once the FabMount is created, sequence of operations are performed using FabMount methods.</p>
<p>The current FabMount methods are:</p>
<ul>
<li>
<p>extrude: Extrudes from an initial FabGeometry this can generate block of material or a
more complex shape line C-channel, I-beam, 8020, etc.</p>
</li>
<li>
<p>Pocket: Removes a pocket of material.</p>
</li>
<li>
<p>Drill: Drill holes for fasteners.</p>
</li>
</ul>
<p>It should be noted that order of the operations may be rearranged to optimize CNC G-code generation.</p>
<h2>Workflow <!-- raw HTML omitted --><!-- raw HTML omitted --></h2>
<p>The basic work flow is done in phases:</p>
<ol>
<li>
<p>Instantiate Tree:</p>
<p>The FabNode tree is instantiated once at the beginning and does change afterwards.
This is performed via classic Python initializer technology where the FabProject
is instantiated first, which instantiates one (or more) FabDocument's, and so
forth until the entire tree is present.</p>
<p>As a side note, the Fab package heavily uses Python both type hints and dataclasses.
See the section <a href="data-classes-and-type-hints">dataclasses and type hints</a> for more information.</p>
<p>The <code>run</code> method on the top level FabProject node is used to perform all of the work:
In short, a Fab program looks like:</p>
<pre><code>def main() -&gt; None:
    project: FabProject = MyProject()
    project.run()
</code></pre>
</li>
<li>
<p>Constraint Propagation.</p>
<p>Constraint propagation is how parametric designs are supported.
Constraint propagation is an iterative process where each FabNode is allowed to
access values defined in other FabNode's to compute new values for itself.
The <code>produce</code> recursively called for each FabNode is the tree
until constraint values no longer change.
It is possible to get into a loop where some constraints do not converge to a final stable value.
When this occurs, Fab system lists the values that did not converge.</p>
</li>
<li>
<p>Solid Construction.</p>
<p>Using the same <code>produce</code> method for defined for each FabNode,
each produce method is called once is &quot;construct&quot; mode.
In this mode, the FabMount objects (mentioned above in the previous section) are activated
and the underlying CadQuery machinery is activated to produce one STEP file per FabSolid.
A STEP file is a standard file format for the interchange of 3D parts and assemblies
by Mechanical CAD program..
In addition, a JSON file is generated that summarizes what was generated.</p>
</li>
<li>
<p>Visualization and CNC.</p>
<p>The FreeCAD program is used for both visualization of the resulting parts and assembly
and for generating CNC G-code files.
For technical reasons, CadQuery can not be subsumed into FreeCad,
so this code has to be run separately.
In the visualization step, the generated JSON file is read and processed causing all of
the previously generated STEP files to be read into FreeCad for viewing purposes.</p>
<p>If CNC G-Code generation is required, the FreeCad CNC Path package is used to generate G-code.
The generated G-code paths can also be visualized using FreeCAD.
Indeed, the FreeCAD Path simulator can be used to simulate the machining process.</p>
</li>
<li>
<p>Fabrication.</p>
<p>The generated <code>.cnc</code>, <code>.dxf</code>, <code>.stl</code> files, can be fed into the appropriate shop machines
to actually fabricate each part.</p>
</li>
</ol>
<h2>Python Modules <!-- raw HTML omitted --><!-- raw HTML omitted --></h2>
<p>The (current) main Python modules are:</p>
<ul>
<li>
<p><a href="docs/Project.html">Project</a>:
The top level FabNode sub-classes of FabProject, FabDocument, and FabAssembly.</p>
</li>
<li>
<p><a href="docs/Solid.html">Solid</a>:
The Solid creation class of FabSolid and FabMount.</p>
</li>
<li>
<p><a href="docs/Geometry.html">Geometry</a>:
The FabPolygon, FabCircle sub-classes of FabGeometry.</p>
</li>
<li>
<p><a href="docs/Node.html">Node</a>:
The base FabNode class and associated FabBox class for describing bounding boxes.</p>
</li>
<li>
<p><a href="doc/Utilities.html">Utilities</a>:
This contains some utility classes like FabColor and FabMaterial.</p>
</li>
</ul>
<p>Additional Python modules are:</p>
<ul>
<li>
<p><a href="docs/Shop.html">Shop</a>:
Classes for defining Shop machines and tooling.</p>
</li>
<li>
<p><a href="docs/CNC.html">CNC</a>:
Classes for accessing the FreeCad Path CNC G-code generation library.</p>
</li>
<li>
<p><a href="docs/Join.html">Join</a>:
Classes for defining fastener stacks of screws, bolts, washers, nuts, etc.</p>
</li>
<li>
<p><a href="docs/Doc.html">Doc</a>:
A program for reading Python files and generating HTML documentation.</p>
</li>
<li>
<p><a href="docs/BOM.html">BOM</a>:
The beginnings of a Bill of Materials manager.</p>
</li>
</ul>
<h2>Type Hints and Data Classes <!-- raw HTML omitted --><!-- raw HTML omitted --></h2>
<p>The Fab project is implemented using both Python type hints and Python data classes.
This section briefly discusses Python type hints and
then goes into significantly more detail on using Python data classes and some of there &quot;quirks&quot;.
This discussion is in preparation for the a simple Fab example in the following section.</p>
<p>In short, Python type hints are based on importing the Python <code>typing</code> module and
decorating variables, class attributes and return values with static type information.
In general, type hints improve the legibility of Python functions and class methods.
In addition, there are various type checking and documentation tools that use these type hints.
In particular, the <code>mypy</code> program reads the type hints and attempts to flag static typing errors.
There are plenty of Python type hint tutorials available in the web
and you should read a few of them to get the idea how Python type hints work.
You are strongly encouraged to learn use <code>mypy</code> on your own code to find and fix static type errors.</p>
<p>Next, all of Fab classes are implemented as the Python data classes.
Python data classes require Python type hints.
There are plenty of type hint web tutorials available,
but most data classes tutorials are pretty basic and miss some important issues.
Please read some of the Python data classes tutorials,
but come back for the discussion about data classes sub-class immediately below.</p>
<p>In short, a Python data class is just a container with named and typed entries.
For example:</p>
<pre><code>     from dataclasses import dataclass, field  # `field` is use later on.
     from typing import List

     @dataclass
     class Book(object):
         Title: str
         Author: str
         ISBN: str

     def __post_init__(self) -&gt; None:   # _post_init__ is discussed later on
         pass
</code></pre>
<p>The Python <code>@dataclass</code> decorator creates an <code>__init__</code>  for the <code>Book</code> class object;
The generated <code>__init__</code> method looks basically as follows:</p>
<pre><code>     def __init__(self, Title: str, Author: str, ISBN: str) -&gt; None:
         self.Title = Title
         self.Author = Author
         self.ISBN = ISBN
         if hasattr(self, &quot;__post_init__&quot;):
             self.__post_init__()
</code></pre>
<p>The <code>~@dataclass</code> decorator generates other methods (e.g. <code>__repr__</code>, <code>__eq__</code>, etc.)
These other generated methods are not of any particular interest to the Fab package.</p>
<p>A trivial example of usage Book class is shown immediately below:</p>
<pre><code>     books: List[Book]: = [
         Book(&quot;Snow Crash&quot;, &quot;Neal Stephenson&quot;, &quot;0553380958&quot;),
         Book(&quot;The Shockwave Rider&quot;, &quot;John Brunner&quot;, &quot;0345467175&quot;),
     ]
</code></pre>
<p>Python data classes can be sub-classed.
For example,</p>
<pre><code>     @dataclass
     class SeriesBook(Book):
          Series: str
          Number: int

     def __post_init__(self) -&gt; None:
          super().__post_init__()
</code></pre>
<p>With usage:</p>
<pre><code>     books.extend([
         SeriesBook(&quot;The Fellowship of the Ring&quot;, &quot;J. R. R. Tolkien&quot;, &quot;0008376123&quot;,
                    &quot;Lord of the Rings&quot;, 1),
         SeriesBook(&quot;The Fellowship of the Ring&quot;, &quot;J. R. R. Tolkien&quot;, &quot;0345339711&quot;,
                    &quot;Lord of the Rings&quot;, 2),
         SeriesBook(&quot;The Return of the King&quot;, &quot;J. R. R. Tolkien&quot;, &quot;1514298139)&quot;,
                    &quot;Lord of the Rings&quot;, 3),
     ])
</code></pre>
<p>You will notice that there is this method called <code>__post_init__()</code> is being shown.
This method is used to initialize attributes that are not specified by <strong>init</strong> arguments.
A contrived example, is to add a <code>Hash</code> attribute to the <code>Book</code> class:</p>
<pre><code>     from dataclasses import import dataclass, field  # Note the added `field` type

     @dataclass
     class Book(object):
         Title: str
         Author: str
         ISBN: str
         Hash: int = field(init=False)  # Not an argument in the __init__() method

     def __post_init__(self) -&gt; None:
         self.Hash = hash(self.Title + self.Author + self.ISBN)

     @dataclass
     class SeriesBook(Book):
          Series: str
          Number: int

     def __post_init__(self) -&gt; None:
          super().__post_init__()
</code></pre>
<p>The <code>Book.__init__()</code> method always calls <code>__post_init__()</code> to initialize attributes that do not
explicit <code>__init__()</code> method arguments (e.g. <code>Hash</code>.)</p>
<p>With that introduction to sub-classing Python data classes, here are the &quot;rules&quot; for
sub-classing Fab classes:</p>
<ol>
<li>
<p>All FabClass's are Python data classes.</p>
</li>
<li>
<p>All FabClass's have a <code>__post_init__()</code> method that <em><strong>MUST</strong></em> get called.</p>
</li>
<li>
<p>Standard usage of Fab classes requires you to sub-class the
FabProject, FabDocument, FabAssembly and FabSolid classes as Python data classes.</p>
</li>
<li>
<p>This means that your sub-classes <em><strong>MUST</strong></em> define a <code>__post_init__()</code> method, <em><strong>AND</strong></em> ...</p>
</li>
<li>
<p>Your <code>__post_init__()</code> method <em><strong>MUST</strong></em> call <code>super().__post_init()</code>.
It can do other stuff as well, but the call to <code>__post_init__()</code> is required.</p>
</li>
</ol>
<p>If you do not follow these steps,
the Fab system will break horribly because <code>__post_init__()</code> does not get properly called
for one of the Fab classes and the Fab code will get confused.</p>
<h2>Bearing Block Example</h2>
<p>(This section is really painful to read and needs to be fixed.)</p>
<!-- raw HTML omitted -->
<h2>Additional documentation <!-- raw HTML omitted --><!-- raw HTML omitted --></h2>
<p>There are some additional miscellaneous Python modules:</p>
<ul>
<li><a href="docs/Doc.html">Doc</a>:
A documentation extraction utility that reads the Python documentation strings and
generates both markdown and HTML documentation files.</li>
<li><a href="embedded_freecad.html">Embedded FreeCAD</a>:
This explains how the Fab modules can be run within or externally from FreeCAD.</li>
<li><a href="fcstd_tar_sync.html">fcstd_tar_sync.py</a>]:
A program that mirrors FreeCAD <code>.fcstd</code> files to <code>.tar</code> files that are more easily stored
under the <code>git</code> revision control system.</li>
<li><a href="coding_documentation.html">Coding/Documentation/Testing</a>:
The coding, documentation, and testing standards uses for code in</li>
<li><a href="LICENSE.md">LICENSE.md</a>: The Open Source license for the Model source files.</li>
</ul>
<h2>Installation <!-- raw HTML omitted --><!-- raw HTML omitted --></h2>
<p>These installation instructions are currently focused towards the Ubuntu 20.04 Linux distribution.</p>
<ul>
<li>
<p>Install the <code>build-essential</code> and <code>git</code> packages:</p>
<p>sudo apt install build-essential git</p>
</li>
<li>
<p>Clone the Fab git repository:</p>
<p>mkdir -p ~/downloads  # or where you like to download git repositories.
cd ~/downloads
git clone ...  # (TBD)</p>
</li>
<li>
<p>Run <code>make install</code>:</p>
<p>make install</p>
</li>
</ul>
