<h1>Tree:</h1>
<p>Tree: ModFab tree management.</p>
<p>The Tree package provides a tree of nodes that mostly corresponds to a FreeCAD tree
as shown in the FreeCAD model view.</p>
<p>The base class is ModFabNode organized as follows:</p>
<ul>
<li>ModFabNode: Tree node base class (can be either a &quot;leaf&quot; or &quot;interior node.)
<ul>
<li>ModFabInterior: An interior TreeNode with children.
<ul>
<li>ModFabRoot: The Root of the ModFabNode tree.</li>
<li>ModFabGroup: A Group of ModFabNode's in a tree.
<ul>
<li>ModFabFile: A Node that corresponds to a <code>.fcstd</code> file.</li>
<li>ModFabAssembly: A group of ModFabAssembly's and/or ModFabPart's.  (Defined in ??)</li>
</ul>
</li>
<li>ModFabSolid: A physical part that is modeled.  (Defined in Solid)</li>
<li>ModFabLink: ???</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The Tree enforces the following constraints:</p>
<ul>
<li>Each ModFabNode name must be compatible with a Python variable name
(i.e. upper/lower letters, digits, and underscores with the character being a letter.)</li>
<li>All of the children of a ModFabNode must have distinct names.</li>
<li>A node may occur only once in the Tree (i.e. DAG = Direct Acyclic Graph.)</li>
<li>The ModFabRoot must be named 'Root'.</li>
</ul>
<p>Each ModFabNode has a <em>FullPath</em> property which is string that contains the ModFabNode Names
from the ModFabRoot downwards separated by a '.'.  The &quot;Root.&quot; is skipped because it is redundant.
Each ModFabNode has an Parent attribute that specifies the parent ModFabNode</p>
<p>ModFabNode implement</p>
<p>The ModFabNode base class implements three recursive methods:</p>
<ul>
<li>configure() -&gt; Tuple[str, ...]:
Recursively propagate configuration values during the configuration phase.
All configured values are returns a tuple of strings of the form &quot;FULL_NAME:PROPERTY_NAME:VALUE&quot;.</li>
<li>check(context) -&gt; Tuple[str, ...]:
Recursively checks for errors during the check phase and returns a tuple of error strings.</li>
<li>build(context) -&gt; Tuple[str, ...]:
Recursively used to build the model and generate any production files (CNC, STL, DWG, etc.)
Any errors and warnings are returned as a tuple of strings.</li>
</ul>
<p>The <em>check</em> and <em>build</em> methods take an <em>context</em> argument which is a dictionarly (Dict[str, Any].)
Values are inserted to communication information from a high node to the lower tree nodes.
The higher level node stuffs a value into the dictionary and lower values can read them back.
Any values stuffed into a lower level are not accessed by the upper level because by convention
each recursion step makes a shallow dictionary copy of the context before passing down to the
next level down.  This is shown below:</p>
<pre><code> # Iterate across children ModFabNode's:
 for child in self.Children:
     child.visit(context.copy(), ...)
</code></pre>
<p>There are currently 1 &quot;invisible&quot; and 3 user visible recursion phases:</p>
<ul>
<li>Setup Phase:
This phase does consistency checking and fills in values such as FullPath.
There are no user hooks in this phase.</li>
<li>Configuration Phase:
The configuration phase is where constraints get propagated between ModFabNode's.  Each
ModFabNode recomputes its configuration value using a method called <em>configure</em>.  This method
can do this by read other values from other ModFabNode's elsewhere in ModFabRoot tree then
computing new values.  This is done repeatably until no more configuration values change or
until it is pretty clear that there is cyclic dependency will not converge.  When convergence
fails, the list of configuration values that did not stabilize are presented.  If there are no
convergence issues, the next phase occurs.</li>
<li>Check Phase:
The check phase recursively performs sanity checking for each ModFabNode in the tree.
The result is a list of error messages.  If the are no errors, the next phase occurs.</li>
<li>Build Phase:
The build phase recursively performs the build operations.  This includes generating
the FreeCAD solids/assemblies and the associated output files.</li>
</ul>
<h2>Table of Contents (alphabetical order):</h2>
<ul>
<li>1 Class: <a href="#tree--modfabinterior">ModFabInterior</a>:</li>
<li>2 Class: <a href="#tree--modfabnode">ModFabNode</a>:
<ul>
<li>2.1 <a href="#tree----check">check()</a>: Check ModFabNode for errors.</li>
<li>2.2 <a href="#tree----configure">configure()</a>: Configure ModFabNode.</li>
<li>2.3 <a href="#tree----configurations-append">configurations_append()</a>: Append specified attributes to configurations list.</li>
<li>2.4 <a href="#tree----produce">produce()</a>: Produce ModFabNode.</li>
</ul>
</li>
<li>3 Class: <a href="#tree--modfabroot">ModFabRoot</a>:
<ul>
<li>3.1 <a href="#tree----configure-constraints">configure_constraints()</a>: Configure the ModFabNode tree until is constraints are stable.</li>
<li>3.2 <a href="#tree----produce">produce()</a>: Produce ModFabNode.</li>
</ul>
</li>
<li>4 Class: <a href="#tree--mynode1">MyNode1</a>:
<ul>
<li>4.1 <a href="#tree----configure">configure()</a>: Configure MyNode1.</li>
</ul>
</li>
<li>5 Class: <a href="#tree--mynode2">MyNode2</a>:
<ul>
<li>5.1 <a href="#tree----configure">configure()</a>: Configure MyNode2.</li>
</ul>
</li>
<li>6 Class: <a href="#tree--mynode2a">MyNode2A</a>:
<ul>
<li>6.1 <a href="#tree----configure">configure()</a>: Configure MyNode2A.</li>
</ul>
</li>
<li>7 Class: <a href="#tree--mynode2b">MyNode2B</a>:
<ul>
<li>7.1 <a href="#tree----configure">configure()</a>: Configure MyNode2B.</li>
</ul>
</li>
<li>8 Class: <a href="#tree--mynode3">MyNode3</a>:
<ul>
<li>8.1 <a href="#tree----configure">configure()</a>: Configure MyNode3.</li>
</ul>
</li>
</ul>
<h2><a name="tree--modfabinterior"></a>1 Class ModFabInterior:</h2>
<p>Represents A
Attributes:</p>
<ul>
<li>Inherited Attributes: <em>Name</em> (str), <em>FullPath</em> (str), <em>Parent</em> (ModFabNod).</li>
<li><em>Children</em> (Tuple[ModFabNode, ...): The children ModFabNode's.</li>
<li><em>ChildrenNames</em> (Tuple[str, ...]): The name's of the children ModFabNode's.</li>
</ul>
<h2><a name="tree--modfabnode"></a>2 Class ModFabNode:</h2>
<p>Represents one node in the tree.
Attributes:</p>
<ul>
<li><em>Name</em> (str): The ModFabNode name.</li>
<li><em>Parent</em> (ModFabNode): The ModFabNode parent.  (Filled in)</li>
<li><em>FullPath</em> (str):  The ModFabNode full path.  (Filled in)</li>
<li>*AttributeNames ([Tuple[str, ...]):
Attribute names to track during configuration.  (Default: () ).
This field is set in the user's <em>configure</em>() method.</li>
</ul>
<h3><a name="tree----check"></a>2.1 <code>ModFabNode.</code>check():</h3>
<p>ModFabNode.check(self) -&gt; typing.Tuple[str, ...]:</p>
<p>Check ModFabNode for errors.</p>
<h3><a name="tree----configure"></a>2.2 <code>ModFabNode.</code>configure():</h3>
<p>ModFabNode.configure(self, tracing: str = '') -&gt; None:</p>
<p>Configure ModFabNode.</p>
<h3><a name="tree----configurations-append"></a>2.3 <code>ModFabNode.</code>configurations_append():</h3>
<p>ModFabNode.configurations_append(self, configurations: typing.List[str], tracing: str = '') -&gt; None:</p>
<p>Append specified attributes to configurations list.</p>
<h3><a name="tree----produce"></a>2.4 <code>ModFabNode.</code>produce():</h3>
<p>ModFabNode.produce(self, context: typing.Dict[str, typing.Any], tracing: str = '') -&gt; typing.Tuple[str, ...]:</p>
<p>Produce ModFabNode.</p>
<h2><a name="tree--modfabroot"></a>3 Class ModFabRoot:</h2>
<p>The Root mode a ModFabNode tree.</p>
<h3><a name="tree----configure-constraints"></a>3.1 <code>ModFabRoot.</code>configure_constraints():</h3>
<p>ModFabRoot.configure_constraints(self, maximum_iterations: int = 20, verbosity: int = 4, tracing: str = '') -&gt; None:</p>
<p>Configure the ModFabNode tree until is constraints are stable.
Arguments:</p>
<ul>
<li><em>maximum_iterations</em> (int): The maximum number of iterations (default: 20).</li>
<li><em>verbosity</em> (int): Verbosity level:
0: No messages.
1: Iteration messages only.
N: Iteration messages with N-1 of the differences:</li>
</ul>
<h3><a name="tree----produce"></a>3.2 <code>ModFabRoot.</code>produce():</h3>
<p>ModFabRoot.produce(self, context: typing.Dict[str, typing.Any], tracing: str = '') -&gt; typing.Tuple[str, ...]:</p>
<p>Produce ModFabNode.</p>
<h2><a name="tree--mynode1"></a>4 Class MyNode1:</h2>
<p>First ModFabNode.</p>
<h3><a name="tree----configure"></a>4.1 <code>MyNode1.</code>configure():</h3>
<p>MyNode1.configure(self, tracing: str = '') -&gt; None:</p>
<p>Configure MyNode1.</p>
<h2><a name="tree--mynode2"></a>5 Class MyNode2:</h2>
<p>MyNode1: First ModFabNode.</p>
<h3><a name="tree----configure"></a>5.1 <code>MyNode2.</code>configure():</h3>
<p>MyNode2.configure(self, tracing: str = '') -&gt; None:</p>
<p>Configure MyNode2.</p>
<h2><a name="tree--mynode2a"></a>6 Class MyNode2A:</h2>
<p>First sub-node of MyNode2.</p>
<h3><a name="tree----configure"></a>6.1 <code>MyNode2A.</code>configure():</h3>
<p>MyNode2A.configure(self, tracing: str = '') -&gt; None:</p>
<p>Configure MyNode2A.</p>
<h2><a name="tree--mynode2b"></a>7 Class MyNode2B:</h2>
<p>Second sub-node of MyNode2.</p>
<h3><a name="tree----configure"></a>7.1 <code>MyNode2B.</code>configure():</h3>
<p>MyNode2B.configure(self, tracing: str = '') -&gt; None:</p>
<p>Configure MyNode2B.</p>
<h2><a name="tree--mynode3"></a>8 Class MyNode3:</h2>
<p>MyNode1: First ModFabNode.</p>
<h3><a name="tree----configure"></a>8.1 <code>MyNode3.</code>configure():</h3>
<p>MyNode3.configure(self, tracing: str = '') -&gt; None:</p>
<p>Configure MyNode3.</p>
