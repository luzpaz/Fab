<h1>Tree:</h1>
<p>Tree: ModFab tree management.</p>
<p>The Tree package provides a tree of nodes that mostly corresponds to a FreeCAD tree
as shown in the FreeCAD model view.</p>
<p>The base class is ModFabNode organized as follows:</p>
<ul>
<li>ModFabNode: Tree node base class.
<ul>
<li>ModFabRoot: The Root of the tree.</li>
<li>ModFabGroup: A Group of ModFabNode's in a tree.
<ul>
<li>ModFabFile: A Node that corresponds to a <code>.fcstd</code> file.</li>
<li>ModFabAssembly: A group of ModFabAssembly's and/or ModFabPart's.  (Defined in ??)</li>
</ul>
</li>
<li>ModFabPart: A physical part that is modeled.  (Defined in Part)</li>
<li>ModFabLink: ???</li>
</ul>
</li>
</ul>
<p>The Tree enforces the following constraints:</p>
<ul>
<li>Each ModFabNode name must be compatible with a Python variable name
(i.e. upper/lower letters, digits, and underscores with the character being a letter.)</li>
<li>All of the children of a ModFabNode must have distinct names.</li>
<li>A node may occur only once in the Tree (i.e. DAG = Direct Acyclic Graph.)</li>
<li>The ModFabRoot must be named 'Root'.</li>
</ul>
<p>Each ModFabNode has a <em>FullPath</em> property which is string that contains the ModFabNode Names
from the ModFabRoot downwards separated by a '.'.  The &quot;Root.&quot; is skipped because it is redundant.
Each ModFabNode has an Parent attribute that specifies the parent ModFabNode</p>
<p>ModFabNode implement</p>
<p>The ModFabNode base class implements three recursive methods:</p>
<ul>
<li>configure(context) -&gt; Tuple[str, ...]:
Recursively propagate configuration values during the configuration phase.
All configured values are returns a tuple of strings of the form &quot;FULL_NAME:PROPERTY_NAME:VALUE&quot;.</li>
<li>check(context) -&gt; Tuple[str, ...]:
Recursively checks for errors during the check phase and returns a tuple of error strings.</li>
<li>build(context) -&gt; Tuple[str, ...]:
Recursively used to build the model and generate any production files (CNC, STL, DWG, etc.)
Any errors and warnings are returned as a tuple of strings.</li>
</ul>
<p>All of these methods take a ModFabContext (called <em>context</em>) that behaves like a dictionary.
Values inserted inserted into the ModFabContext as ModFabNode tree is recursively traversed.
Lower levels in the tree traversal can read values from higher in the traversal and insert
values for lower levels in the traversal.  In order to prevent &quot;dictionary pollution&quot;, the
ModFabContext's are actually copied prior to being used in a lower level.  This is done as follows:</p>
<pre><code> # Iterate across children ModFabNode's:
 for child_node in self.Children:
     child_context: ModFabContext
     # Open a fresh *child_context* the is used by *child_node* and cleaned up upon return:
     with current_context.child() as child_context:
         child_node.visit(child_context, ...)
</code></pre>
<p>There are currently 3 recursion phases:</p>
<ul>
<li>Configuration Phase:
The configuration phase is where constraints get propagated between ModFabNode's.  Each
ModFabNode recomputes its configuration values.  It can do this by reading other values
from ModFabNode's elsewhere in ModFabRoot tree then computing new values.  This is done
repeatably until no more configuration values change or until it is pretty clear that
there is cyclic dependency will not converge.  When convergence fails, the list of
configuration values that did not stabilize are presented.  If there are no convergence
issues, the next phase occurs.</li>
<li>Check Phase:
The check phase recursively performs sanity checking for each ModFabNode in the tree.
The result is a list of error messages.  If the are no errors, the next phase occurs.</li>
<li>Build Phase:
The build phase recursively performs the build operations.  This includes generating
the FreeCAD solids/assemblies and the associated output files.</li>
</ul>
<h2>Table of Contents (alphabetical order):</h2>
<ul>
<li>1 Class: <a href="#tree--modfabcontext">ModFabContext</a>:
<ul>
<li>1.1 <a href="#tree----child">child()</a>: Return child MadFabContext for next recursion level.</li>
</ul>
</li>
<li>2 Class: <a href="#tree--modfabnode">ModFabNode</a>:
<ul>
<li>2.1 <a href="#tree----check">check()</a>: Check ModFabNode for errors.</li>
<li>2.2 <a href="#tree----configure">configure()</a>: Configure ModFabNode.</li>
<li>2.3 <a href="#tree----get-configurations">get_configurations()</a>: Return configurations strings for named attributes.</li>
<li>2.4 <a href="#tree----produce">produce()</a>: Produce ModFabNode.</li>
</ul>
</li>
<li>3 Class: <a href="#tree--modfabroot">ModFabRoot</a>:
<ul>
<li>3.1 <a href="#tree----configure-constraints">configure_constraints()</a>: Configure the ModFabNode tree until is constraints are stable.</li>
</ul>
</li>
<li>4 Class: <a href="#tree--mynode1">MyNode1</a>:
<ul>
<li>4.1 <a href="#tree----configure">configure()</a>: Configure MyNode1.</li>
</ul>
</li>
<li>5 Class: <a href="#tree--mynode2">MyNode2</a>:
<ul>
<li>5.1 <a href="#tree----configure">configure()</a>: Configure MyNode1.</li>
</ul>
</li>
<li>6 Class: <a href="#tree--mynode3">MyNode3</a>:
<ul>
<li>6.1 <a href="#tree----configure">configure()</a>: Configure MyNode1.</li>
</ul>
</li>
</ul>
<h2><a name="tree--modfabcontext"></a>1 Class ModFabContext:</h2>
<p>ModeFabContext: ModFabNode tree context.
A ModeFabContext is a dictionary for storing information needed during the various
ModFabNode tree recrusive</p>
<h3><a name="tree----child"></a>1.1 <code>ModFabContext.</code>child():</h3>
<p>ModFabContext.child(self) -&gt; 'ModFabContext':</p>
<p>Return child MadFabContext for next recursion level.</p>
<h2><a name="tree--modfabnode"></a>2 Class ModFabNode:</h2>
<p>Represents one node in the tree.
Attributes:</p>
<ul>
<li><em>Name</em> (str): The ModFabNode name.</li>
<li><em>Parent</em> (ModFabNode): The ModFabNode parent.</li>
<li><em>ChildrenNodes</em> (Tuple[ModFabNode, ...): The children ModFabNode's.</li>
<li><em>FullPath</em> (str):  The ModFabNode full path.</li>
</ul>
<h3><a name="tree----check"></a>2.1 <code>ModFabNode.</code>check():</h3>
<p>ModFabNode.check(self, context: 'ModFabContext') -&gt; typing.Tuple[str, ...]:</p>
<p>Check ModFabNode for errors.</p>
<h3><a name="tree----configure"></a>2.2 <code>ModFabNode.</code>configure():</h3>
<p>ModFabNode.configure(self, context: 'ModFabContext', tracing: str = '') -&gt; typing.Tuple[str, ...]:</p>
<p>Configure ModFabNode.</p>
<h3><a name="tree----get-configurations"></a>2.3 <code>ModFabNode.</code>get_configurations():</h3>
<p>ModFabNode.get_configurations(self, attribute_names: typing.Tuple[str, ...]) -&gt; typing.Tuple[str, ...]:</p>
<p>Return configurations strings for named attributes.</p>
<h3><a name="tree----produce"></a>2.4 <code>ModFabNode.</code>produce():</h3>
<p>ModFabNode.produce(self, context: 'ModFabContext', tracing: str = '') -&gt; typing.Tuple[str, ...]:</p>
<p>Produce ModFabNode.</p>
<h2><a name="tree--modfabroot"></a>3 Class ModFabRoot:</h2>
<p>The Root mode a ModFabNode tree.</p>
<h3><a name="tree----configure-constraints"></a>3.1 <code>ModFabRoot.</code>configure_constraints():</h3>
<p>ModFabRoot.configure_constraints(self, maximum_iterations: int = 20, verbosity: int = 4, tracing: str = '') -&gt; None:</p>
<p>Configure the ModFabNode tree until is constraints are stable.
Arguments:</p>
<ul>
<li><em>maximum_iterations</em> (int): The maximum number of iterations (default: 20).</li>
<li><em>verbosity</em> (int): Verbosity level:
0: No messages.
1: Iteration messages only.
N: Iteration messages with N-1 of the differences:</li>
</ul>
<h2><a name="tree--mynode1"></a>4 Class MyNode1:</h2>
<p>First ModFabNode.</p>
<h3><a name="tree----configure"></a>4.1 <code>MyNode1.</code>configure():</h3>
<p>MyNode1.configure(self, context: typing.Dict[str, typing.Any], tracing: str = '') -&gt; typing.Tuple[str, ...]:</p>
<p>Configure MyNode1.</p>
<h2><a name="tree--mynode2"></a>5 Class MyNode2:</h2>
<p>MyNode1: First ModFabNode.</p>
<h3><a name="tree----configure"></a>5.1 <code>MyNode2.</code>configure():</h3>
<p>MyNode2.configure(self, context: typing.Dict[str, typing.Any], tracing: str = '') -&gt; typing.Tuple[str, ...]:</p>
<p>Configure MyNode1.</p>
<h2><a name="tree--mynode3"></a>6 Class MyNode3:</h2>
<p>MyNode1: First ModFabNode.</p>
<h3><a name="tree----configure"></a>6.1 <code>MyNode3.</code>configure():</h3>
<p>MyNode3.configure(self, context: typing.Dict[str, typing.Any], tracing: str = '') -&gt; typing.Tuple[str, ...]:</p>
<p>Configure MyNode1.</p>
