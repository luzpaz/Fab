#!/home/wayne/public_html/projects/Fab/squashfs-root/usr/bin/python
"""CQtoFC: A module for reading CadQuery generated STEP files into FreeCAD.

This shell script converts the JSON file (.json) and associated STEP (.stp) files generated by
from a FabProject and converts them into FreeCAD document files (.FCStd) and optionally
generates CNC G code (`.ngc`) files.

This program is meant to be run by the FreeCAD Python interpreter.  Since there is no easy
way to pass command line arguments the interpreter, there is a shell file called `cq2fc.sh`
sets everything up to run in FreeCAD.  It passes arguments/options in via Environment variables.
(This very is a very crude but effective workaround to the problem.)  If you want to manually
run this from the command line, the following syntax should work:
```
FLAGS="c" JSON="/tmp/TestProject.json" ./freecad19 -c ./CQtoFC.py
```
Where `FLAGS="..."` sets the `FLAGS` environment variable and `JSON="..."` sets the `JSON`
environment variable for just one execution of the freecad19 python interpreter in -c
(console mode).  The `CQtoFC.py` file is this program.
"""

# <--------------------------------------- 100 characters ---------------------------------------> #

# In order to support debugging with the `pudb` Python debugger, it is necessary to run
# outside of the freecad19 Python interpreter.  The freecad19 Python interpreter puts the
# console into a weird mode that does not work with `pudb` debugger.  In order to set up
# debugging.  Do the following:
# ```
# python3 -m pip install pudb  # Only needs to be done once.  It lands in `~/.local/lib/...`
# rm -rf squashfs  # Remove any previously unpacked AppImage files.
# ./freecad19 --appimage-extract  # Extract new AppImage files.
# # Manually copy `pudb` into the `squashfs1 tree:
# cp -r ~/.local/lib/python3.8/site-packages/pudb ./squashfs-root/usr/lib/python3.8/site-packages/
# ```
# To enable `pudb`, uncomment `import pudb` and `pudb.start()`:
# TODO: Replace `/home/wayne`:
SHARP_EXEC_PATH = "/home/wayne/public_html/projects/Fab/squashfs-root/usr/bin/python"
import sys
if sys.executable == SHARP_EXEC_PATH:
    sys.path[1:1] = [  # Insert list into sys.path at index 1.
        "/home/wayne/public_html/projects/Fab/squashfs-root/usr/lib",
        "/home/wayne/public_html/projects/Fab/squashfs-root/usr/Ext",
        "/home/wayne/public_html/projects/Fab/squashfs-root/usr/bin",
        "/home/wayne/.local/lib/python3.8/site-packages",
    ]
# Uncomment these lines to fire up the debugger:
# import pudb  # Import the debugger
# pudb.start()  # Start it right now:

# Standard Python library imports:
from dataclasses import dataclass, field
import json
import os
from pathlib import Path as FilePath  # The Path library uses `Path`, hence `FilePath`
from typing import Any, cast, List, Dict, IO, Optional, Set, Tuple, Union

# Generic FreeCAD imports:
import FreeCAD  # type: ignore
import FreeCADGui  # type: ignore
_ = FreeCAD
_ = FreeCADGui

# Path library imports:
import Path  # type: ignore
import PathScripts  # type: ignore
_ = PathScripts
from PathScripts import PathToolBit  # type: ignore
from PathScripts import PathJob, PathProfile, PathPostProcessor, PathUtil  # type: ignore
from PathScripts import PathToolController, PathPocket  # type: ignore
_ = PathToolBit  # TODO: remove
_ = PathJob  # TODO: remove
_ = PathProfile  # TODO: remove
_ = PathPostProcessor  # TODO: remove
_ = PathUtil  # TODO: remove
_ = PathToolController  # TODO: remove
_ = PathPocket  # TODO: remove

# This causes out flake8 to think App are defined.
# It is actually present in the FreeCAD Python exectution envriorment.
App: Any
if False:
    App = None

# FreeCAD has two different importers depending upon whether it is GUI mode or not.
from FreeCAD import Vector  # type: ignore
if App.GuiUp:  # type: ignore
    import FreeCADGui as Gui  # type: ignore
    from FreeCAD import ImportGui as FCImport  # type: ignore
    from PathScripts import PathJobGui  # type: ignore
    _ = PathJobGui  # TODO: Remove
else:
    from FreeCAD import Import as FCImport  # type: ignore


# FabCQtoFC:
@dataclass
class FabCQtoFC(object):
    """FabCQtoFC: Import CadQuery .step files into FreeCAD."""

    JsonPath: FilePath
    ToolsPath: Optional[FilePath]
    CNC: bool
    AllDocuments: List[Any] = field(init=False, repr=False)
    CurrentGroup: Any = field(init=False, repr=False)
    CurrentJob: Any = field(init=False, repr=False)
    CurrentJobName: Any = field(init=False, repr=False)
    CurrentSolidName: Any = field(init=False, repr=False)
    CurrentLink: Any = field(init=False, repr=False)
    CurrentNormal: Any = field(init=False, repr=False)
    CurrentPart: Any = field(init=False, repr=False)
    PendingLinks: List[Tuple[Any, Any]] = field(init=False, repr=False)
    ProjectDocument: Any = field(init=False, repr=False)
    StepsDocument: Any = field(init=False, repr=False)
    ToolControllersTable: Dict[int, Any] = field(init=False, repr=False)  # Ctl# => controller
    ToolNumbersTable: Dict[int, Any] = field(init=False, repr=False)  # Tool# => tool
    ToolsTable: Dict[str, Any] = field(init=False, repr=False)  # Tool name => tool

    # FabCQtoFC.__post_init__():
    def __post_init__(self) -> None:
        """Initialize FabCQtoFC."""
        assert isinstance(self.JsonPath, FilePath), self.JsonPath
        self.AllDocuments = []
        self.CurrentGroup = None
        self.CurrentJob = None
        self.CurrentJobName = None
        self.CurrentLink = None
        self.CurrentNormal = None
        self.CurrentSolidName = None
        self.CurrentPart = None
        self.PendingLinks = []
        self.ProjectDocument = None
        self.ProperitiesVerified = False
        self.StepsDocument = None
        self.ToolControllersTable = {}
        self.ToolNumbersTable = {}
        self.ToolsTable = {}

    # FabCQtoFC.fetch_tool():
    def fetch_tool(self, bit_name: str) -> Any:
        """Fetch a tool from the Tools/Bit and store into ToolsTable."""
        tools_table: Dict[str, Any] = self.ToolsTable
        if bit_name not in tools_table:
            # Create the *bit_path* file name and verify that it exists:
            assert isinstance(self.ToolsPath, FilePath), f"{type(self.ToolsPath)=}"
            bit_directory: FilePath = self.ToolsPath / "Bit"
            bit_path: FilePath = bit_directory / f"{bit_name}.fctb"
            if not bit_path.exists():
                raise RuntimeError(f"{str(bit_path)} file does not exist")

            # Read *bit_path* contents in and convert into *bit_json*:
            bit_file: IO[str]
            with open(bit_path, "r") as bit_file:
                bit_text: str = bit_file.read()
            bit_json: Any = json.loads(bit_text)

            # Convert *bit_json* into *tool* and save it:
            tool: Any = PathToolBit.Factory.CreateFromAttrs(bit_json, bit_name)
            tool.Visibility = False
            tools_table[bit_name] = tool
        return tools_table[bit_name]

    # FabCQtoFC.get_tool_and_controller():
    def get_tool_and_controller(
            self, json_dict: Dict[str, Any], label: str, indent: str, tree_path: Tuple[str, ...],
            tracing: str = "") -> Tuple[Any, Any]:
        """Extract tool controller and associated tool bit from a JSON node."""
        if tracing:
            print(f"{tracing}=>FabCQtotFC.get_tool_and_controller(*, {label}, {tree_path})")
        tool_controller_index = cast(
            int, self.key_verify("ToolControllerIndex", json_dict, int,
                                 tree_path, "get_tool_and controller.ToolControllerIndex"))
        tool_controllers_table: Dict[int, Any] = self.ToolControllersTable
        tool: Any
        tool_controller: Any
        if tool_controller_index in tool_controllers_table:
            tool_controller = tool_controllers_table[tool_controller_index]
            tool = tool_controller.Tool
        else:
            # Extract the *tool_controller_dict* from *json_dict*:
            tool_controller_dict = cast(
                Dict[str, Any], self.key_verify(
                    "ToolController", json_dict, dict,
                    tree_path, "get_tool_and controller.ToolController"))

            # Extract the tool controller fields from *json_dict*:
            bit_name = cast(
                str, self.key_verify(
                    "BitName", tool_controller_dict, str,
                    tree_path, "get_tool_and controller.BitName"))
            cooling = cast(
                str, self.key_verify(
                    "Cooling", tool_controller_dict, str,
                    tree_path, "get_tool_and controller.Cooling"))
            horizontal_feed = cast(
                float, self.key_verify(
                    "HorizontalFeed", tool_controller_dict, float,
                    tree_path, "get_tool_and controller.HoriztontalFeed"))
            horizontal_rapid = cast(
                float, self.key_verify(
                    "HorizontalRapid", tool_controller_dict, float,
                    tree_path, "get_tool_and controller.HoriztontalRapid"))
            spindle_direction = cast(
                bool, self.key_verify(
                    "SpindleDirection", tool_controller_dict, bool,
                    tree_path, f"get_tool_and controller.SpindleDirection {tool_controller_dict}"))
            spindle_speed = cast(
                float, self.key_verify(
                    "SpindleSpeed", tool_controller_dict, float,
                    tree_path, "get_tool_and controller.SpindleSpeed"))
            tool_number = cast(
                int, self.key_verify(
                    "ToolNumber", tool_controller_dict, int,
                    tree_path, "get_tool_and controller.ToolNumber"))
            vertical_feed = cast(
                float, self.key_verify(
                    "VerticalFeed", tool_controller_dict, float,
                    tree_path, "get_tool_and controller.VerticalFeed"))
            vertical_rapid = cast(
                float, self.key_verify(
                    "VerticalRapid", tool_controller_dict, float,
                    tree_path, "get_tool_and controller.VerticalRapid"))
            _ = cooling  # Extremely weird, tool controllers do not cooling.

            # Create the *tool_controller*:
            tool_controller = PathToolController.Create(name=label)

            # Look up the *tool* using *tool_number* and/or *bit_name*:
            if tool_number in self.ToolNumbersTable:
                tool = self.ToolNumbersTable[tool_number]
            else:
                tool = self.fetch_tool(bit_name)
                self.ToolNumbersTable[tool_number] = tool
            tool_controller.Tool = tool

            # A helper method to fill in the *tool_controller* fields:
            def tool_controller_set(tool_controller: Any, attribute_name: str,
                                    value: Union[int, str, float]) -> None:
                """Set a field value in the tool controller."""
                if hasattr(tool_controller, attribute_name):
                    # Make sure that there is no expression present for *attribute_name*.
                    # If this is not done, the following value set does not "take".
                    tool_controller.setExpression(attribute_name, None)
                    setattr(tool_controller, attribute_name, value)
                else:
                    raise RuntimeError(f"ToolController does not have Attribute {attribute_name}")

            # Load up the contents of *tool_controller*:
            tool_controller_set(tool_controller, "HorizFeed", horizontal_feed)
            tool_controller_set(tool_controller, "HorizRapid", horizontal_rapid)
            tool_controller_set(tool_controller, "SpindleDir", spindle_direction)
            tool_controller_set(tool_controller, "SpindleSpeed", spindle_speed)
            tool_controller_set(tool_controller, "ToolNumber", tool_number)
            tool_controller.Tool = tool
            tool_controller_set(tool_controller, "VertFeed", vertical_feed)
            tool_controller_set(tool_controller, "VertRapid", vertical_rapid)
            # Weird! There is to coolant field in a tool controller yet.
            tool_controllers_table[tool_controller_index] = tool_controller

        result: Tuple[Any, Any] = (tool, tool_controller)
        if tracing:
            print(f"{tracing}<=FabCQtotFC.get_tool_and_controller("
                  f"*, {label}, {tree_path})=>{result}")
        return result

    # FabCQtoFC.flush_job(self):
    def flush_job(self, tracing: str = ""):
        if tracing:
            print("{tracing}=>FabCQtoFC.flush_job()")
        job: Any = self.CurrentJob
        job_name: Any = self.CurrentJobName
        if job:
            # Create *post_list* which is a list of tool controllers and *operations*:
            post_list: List[Any] = []
            current_tool_number: int = -99999999
            for index, operation in enumerate(job.Operations.Group):
                tool_controller: Any = PathUtil.toolControllerForOp(operation)
                tool: Any = tool_controller.Tool
                if tracing:
                    print(f"{tracing}{tool=}")
                    print(dir(tool))
                    print("")

                if tool_controller is not None:
                    if tool_controller.ToolNumber != current_tool_number:
                        post_list.append(tool_controller)
                        current_tool_number = tool_controller.ToolNumber
                post_list.append(operation)

            # Generate the gcode and output it to *gcode_path*:
            gcode_path = f"/tmp/{job_name}.ngc"
            post: Any = PathPostProcessor.PostProcessor.load(job.PostProcessor)
            post.export(post_list, gcode_path, job.PostProcessorArgs)

        self.CurrentJob = None
        self.CurrentJobName = None
        if tracing:
            print("{tracing}<=FabCQtoFC.flush_job()")

    # CQtoPy.verify_properties():
    def verify_properties(self, tracing: str = "") -> None:
        """Verify that all of the properties match their associated 'info' dictionaries."""
        # This method must be called after a document has been created.
        if tracing:
            print(f"{tracing}=>CQtoPy.verify_properties()")

        def match(label: str, properties: Set[str], infos: Set[str]) -> None:
            """Match a properties with information set."""
            if properties != infos:
                print(f"CQtoPy.verify_properties.match('{label}', *, *):")
                print(f"{sorted(properties)=}")
                print(f"{sorted(infos)=}")
                print()
                print(f"{sorted(properties - infos)=}")
                print(f"{sorted(infos - properties)=}")
                assert False

        if not self.ProperitiesVerified:
            self.ProperitiesVerified = True

            profile: Any = PathProfile.Create("IgnoreThisProfile")
            profiles: Set[str] = set(profile.PropertiesList)
            pocket: Any = PathPocket.Create("IgnoreThisPocket")  # => "Path::FeaturePython".
            pockets: Set[str] = set(pocket.PropertiesList)
            commons: Set[str] = profiles & pockets

            common_infos: Set[str] = set(self.get_common_properties().keys())
            extrude_infos: Set[str] = set(self.get_extrude_properties().keys())
            pocket_infos: Set[str] = set(self.get_pocket_properties().keys())

            match("profile", profiles, extrude_infos)
            match("pocket", pockets, pocket_infos)
            match("commmon", commons, common_infos)
        if tracing:
            print(f"{tracing}<=CQtoPy.verify_properties()")

    # FabCQtoFC.process():
    def process(self, indent: str = "", tracing: str = "") -> None:
        """Process a JSON file into a FreeCAD documents."""
        next_tracing: str = tracing + "  " if tracing else ""
        if tracing:
            print(f"{tracing}=>FabCQtFC.process({str(self.JsonPath), {self.ToolsPath}})")

        # Create the *steps_document*:
        json_directory: FilePath = self.JsonPath.parent
        steps_document: Any = App.newDocument("Step_Files")  # type: ignore
        self.StepsDocument = steps_document
        self.AllDocuments.append(steps_document)

        # Read in *json_path*:
        json_file: IO[str]
        json_text: str = ""
        if self.JsonPath.suffix != ".json":
            raise RuntimeError(f"JSON file must have `.json` suffix: '{str(self.JsonPath)}'")
        if tracing:
            print(f"{tracing}Loading {str(self.JsonPath)}")
        with open(self.JsonPath, "r") as json_file:
            json_text = json_file.read()
        if tracing:
            print(f"{tracing}Parsing {str(self.JsonPath)}")
        json_root = cast(Dict[str, Any], json.loads(json_text))
        assert isinstance(json_root, dict), json_root

        # Recursively walk the tree starting at *json_root*:
        if tracing:
            print(f"{tracing}Processing {str(self.JsonPath)}")
        self.node_process(("Root",), json_root, indent=indent, tracing=next_tracing)

        # Save *all_documents*:
        document: Any
        for document in self.AllDocuments:
            save_path: FilePath = json_directory / f"{document.Label}.FCStd"
            if save_path.exists():
                save_path.unlink()
            document.recompute()
            document.saveAs(str(save_path))
        self.flush_job()

        # Install all of the *pending_links*:
        pending_link: Tuple[Any, Any]
        link: Any
        part: Any
        for link, part in self.PendingLinks:
            link.setLink(part)
        if tracing:
            print(f"{tracing}<=FabCQtFC.process({str(self.JsonPath), {self.ToolsPath}})")

    # FabCQtoFC.type_verify():
    def type_verify(self, value: Any, value_type: type,
                    tree_path: Tuple[str, ...], tag: str) -> None:
        """Verify JSON type."""
        if not isinstance(value, value_type):
            message: str = f"{tree_path}: {tag}: Got {type(value)}, not {value_type}"
            print(message)
            assert False, message

    # FabCQtoFC.key_verify():
    def key_verify(self, key: str, table: Dict[str, Any], key_type: type,
                   tree_path: Tuple[str, ...], tag: str) -> Any:
        """Verify key is in dictionary and has correct type."""
        if key not in table:
            message: str = f"{tree_path}: {tag}: '{key}' is not one of {tuple(table.keys())}'"
            print(message)
            assert False, message
        value: Any = table[key]
        self.type_verify(value, key_type, tree_path, tag)
        return value

    # FabCQtoFC.process_json():
    def process_json(
            self, json_dict: Dict[str, Any], obj: Any,
            info: Dict[str, Dict[str, Any]], tracing: str = ""
    ) -> None:
        """Transfer JSON values into Path operation object.

        Arguments:
        * *json_dict* (Dict[str, Any]):
          A dictionary from a JSON file that contains the object values:
        * *obj* (Any):
          A Path opertation object (e.g. contour, pocket, drill, etc.) that has properties
          to be set.  This object must have a `PropertiesList` attribute.
        * *info* (Dict[str, Dict[str, Any]]):
          This a dictionary of dictionaries.  The top level dictionary keys must be 1-to-1
          with the keys returned by the `PropertiesList` attribute.  The sub-dictionary for
          each property specifies additional information:
          * "doc": (str):
            The documentation string associated with the property.  When present, it must
            exactly match corresponding object documentation line returned by the
            `getDocumentationProperty()` method.  This helps document what each property
            does in the code.
          * "allowed": (Set[str]):
            When present, the property must be match one of the values in the set.
          * "ignore: (None):
            When present, this property is ignored.
        """
        if tracing:
            print(f"{tracing}=>FabCQtoFC.process_json(*, *, *)")
            print(f"{dir(obj)=}")

        # Verify that required methods a present:
        if not hasattr(obj, "PropertiesList"):
            raise RuntimeError(
                "FabCQtoFC.process_json(): No getProperties() method present")
        if not hasattr(obj, "getDocumentationOfProperty"):
            raise RuntimeError(
                "FabCQtoFC.process_json(): No getDocumentationOfProperty() method present")

        # Extract *info_properties*, *ignore_properteries* and *extra_properties* from *info*:
        property_name: str
        property_info: Dict[str, Any]
        ignore_properties: Set[str] = {  # Only ones which are tagged with "ignore".
            property_name
            for property_name, property_info in info.items()
            if "ignore" in property_info
        }
        extra_properties: Set[str] = {  # Only ones which are tagged with "extra".
            property_name
            for property_name, property_info in info.items()
            if "extra" in property_info
        }

        # Extra *actual_properties* from *obj*:
        actual_properties: Set[str] = set(obj.PropertiesList)

        # The incoming JSON entries have a preceding "_" that needs to be stripped off.
        # FYI, the "_" ensures that required entries like "Label" and "Kind" get sorted first
        # when the JSON is pretty printed.  Any following "children" list always sorts last.
        json_key: str
        json_properties: Set[str] = set([
            json_key[1:] for json_key in json_dict.keys()
            if json_key.startswith("_")
        ])

        desired_jsons: Set[str] = json_properties - extra_properties
        desired_actuals: Set[str] = actual_properties - ignore_properties
        if desired_jsons != desired_actuals:
            raise RuntimeError(
                "FabCQtoFC.process_json(): Property mismatch:\n"
                f"{sorted(desired_jsons - desired_actuals)=}\n"
                f"{sorted(desired_actuals - desired_jsons)=}\n"
            )

        # Sweep through *properties*:
        if tracing:
            print(f"{tracing}{json_properties=}")
        for property_name, property_info in info.items():
            info_key: str
            info_value: Any
            if "doc" in property_info:
                actual_documentation: str = obj.getDocumenationProperty()
                assert isinstance(property_info, str), property_info
                if actual_documentation != property_info:
                    raise RuntimeError(
                        "FabCQtoFC.process_json(): documentation mismatch:\n"
                        f"Actual: '{actual_documentation}'\n"
                        f"Wanted: '{property_info}'")
            if "ignore" not in property_info and "extra" not in property_info:
                property_value: Any = getattr(obj, property_name)
                property_type: type = type(property_value)
                json_value: Any = json_dict[f"_{property_name}"]  # JSON keys have "_" key prefix.
                json_type: type = type(json_value)
                if "type" in property_info:
                    property_type = property_info["type"]
                if isinstance(json_type, str):
                    enumeration_values: List[str] = obj.getEnumererationsOfProperty(property_name)
                    if json_value not in enumeration_values:
                        raise RuntimeError(
                            f"FabCQtoFC.process_json(): {property_name=} has "
                            f"{property_value=} which is not one of {sorted(enumeration_values)}")
                if property_type != json_type:
                    raise RuntimeError(
                        "FabCQtoFC.process_json(): "
                        f"{property_name=}: {property_type=} != {json_type=}")
                setattr(obj, property_name, json_value)

        if tracing:
            print(f"{tracing}<=FabCQtoFC.process_json(*, *, *)")

    # FabCQtoFC.node_process():
    def node_process(self, tree_path: Tuple[str, ...], json_dict: Dict[str, Any],
                     indent: str = "", tracing: str = "") -> None:
        """Process one 'node' of JSON content."""

        # Set up *tracing* and pretty print *indent*:
        next_tracing: str = tracing + "  " if tracing else ""
        next_indent = indent + "  " if indent else ""
        if tracing:
            print(f"{tracing}=>FabCQtoFC.child_process(*, {tree_path}, '{indent}')")
            print(f"{tracing}{json_dict=}")

        # Do some sanity checking:
        error_message: str
        self.type_verify(json_dict, dict, tree_path, "json_dict")
        kind = cast(str, self.key_verify("Kind", json_dict, str, tree_path, "Kind"))
        label = cast(str, self.key_verify("Label", json_dict, str, tree_path, "Label"))
        if indent:
            print(f"{indent}{label}:")
            print(f"{indent} Kind: {kind}")

        # Verify that that *kind* is one of the *allowed_kinds*:
        allowed_kinds: Tuple[str, ...] = (
            "Project", "Document", "Assembly", "Solid", "Mount",
            "Extrude", "Pocket", "Drill")
        if kind not in allowed_kinds:
            error_message = f"{tree_path}: Node kind '{kind}' not one of {allowed_kinds}"
            print(error_message)
            assert False, error_message

        # Dispatch on *kind*:
        if kind == "Project":
            pass
        elif kind == "Document":
            self.process_document(json_dict, label, indent, tree_path, tracing=next_tracing)
        elif kind == "Assembly":
            self.process_assembly(json_dict, label, indent, tree_path, tracing=next_tracing)
        elif kind == "Solid":
            self.process_solid(json_dict, label, indent, tree_path, tracing=next_tracing)
        elif kind == "Mount":
            self.process_mount(json_dict, label, indent, tree_path, tracing=next_tracing)
        elif kind == "Extrude":
            self.process_extrude(json_dict, label, indent, tree_path, tracing=next_tracing)
        elif kind == "Pocket":
            self.process_pocket(json_dict, label, indent, tree_path, tracing=next_tracing)
        else:
            message = f"{kind} not one of {allowed_kinds}"
            print(message)
            assert False, message

        # Recursively process any *chidren* JSON nodes:
        if "children" in json_dict:
            children = cast(List[Dict[str, Any]],
                            self.key_verify("children", json_dict, list, tree_path, "Children"))
            if indent:
                print(f"{indent} children ({len(children)}):")

            child_dict: Dict[str, Any]
            for child_dict in children:
                self.type_verify(child_dict, dict, tree_path, "Child")
                child_name = cast(str,
                                  self.key_verify("Label", child_dict, str, tree_path, "Label"))
                child_tree_path: Tuple[str, ...] = tree_path + (child_name,)
                self.node_process(child_tree_path, child_dict,
                                  indent=next_indent, tracing=next_tracing)
        if tracing:
            print(f"{tracing}<=FabCQtoFC.child_process({tree_path}, '{indent}')")

    # FabCQtoFC.process_assembly():
    def process_assembly(self, json_dict: Dict[str, Any], label: str,
                         indent: str, tree_path: Tuple[str, ...], tracing: str = "") -> None:
        if tracing:
            print(f"{tracing}=>FabCQtoFC.process_assembly(*, '{label}', {tree_path})")
        if self.CurrentGroup:
            self.CurrentGroup = self.CurrentGroup.newObject("App::DocumentObjectGroup", label)
        else:
            self.CurrentGroup = self.ProjectDocument.addObject("App::DocumentObjectGroup", label)
        if tracing:
            print(f"{tracing}<=FabCQtoFC.process_assembly(*, '{label}', {tree_path})")

    # FabCQtoFC.process_document():
    def process_document(self, json_dict: Dict[str, Any], label: str,
                         indent: str, tree_path: Tuple[str, ...], tracing: str = "") -> None:
        """Process a Document JSON node."""
        # next_tracing: str = tracing + " " if tracing else ""
        if tracing:
            print(f"{tracing}=>FabCQtoFC.process_document(*, '{label}', {tree_path})")
        file_path: str = cast(str, self.key_verify(
            "_FilePath", json_dict, str, tree_path, "Document._File_Path"))
        project_document = App.newDocument(label)  # type: ignore
        project_document.Label = label
        if indent:
            print(f"{indent} _FilePath: {file_path}")
            self.ProjectDocument = project_document
            self.AllDocuments.append(project_document)
        if tracing:
            print(f"{tracing}<=FabCQtoFC.process_document(*, '{label}', {tree_path})")

    # FabCQtoFC.process_extrude():
    def process_extrude(self, json_dict: Dict[str, Any], label: str,
                        indent: str, tree_path: Tuple[str, ...], tracing: str = "") -> None:
        """Process an Extrude JSON node."""
        next_tracing: str = tracing + " " if tracing else ""
        if tracing:
            print(f"{tracing}=>FabCQtoFC.process_extrude(*, '{label}', {tree_path})")
        active = cast(bool, self.key_verify("_Active", json_dict, bool, tree_path,
                                            "Extrude._Active"))
        if tracing:
            print(f"{tracing}Creating job")
        job = self.CurrentJob
        normal = self.CurrentNormal
        assert job is not None, "No job present"

        if active:
            tool, tool_controller = self.get_tool_and_controller(
                json_dict, label, indent, tree_path, tracing=next_tracing)

            obj: Any = self.CurrentPart
            name: str = f"{job.Label}_profile"
            aligned_face_name: str = self.get_aligned_face_name(obj, normal, tracing=next_tracing)
            if aligned_face_name:
                if tracing:
                    print(f"{tracing}Create profile")
                # This prints:
                # PathSetupSheet.INFO: SetupSheet has no support for TestSolid_Step_Top_profile
                profile = PathProfile.Create(name)
                if tracing:
                    print(f"{tracing}profile created")
                profile.Base = (obj, aligned_face_name)
                if True:
                    step_file = cast(str, self.key_verify(
                        "StepFile", json_dict, str, tree_path, "Extrude._StepFile"))
                    depth = cast(float, self.key_verify(
                        "_Depth", json_dict, float, tree_path, "Extrude._Depth"))
                    final_depth = cast(float, self.key_verify(
                        "_FinalDepth", json_dict, float, tree_path, "Extrude._FinalDepth"))
                    step_down = cast(float, self. key_verify(
                        "_StepDown", json_dict, float, tree_path, "Extrude._StepDown"))
                    start_depth = cast(float, self.key_verify(
                        "_StartDepth", json_dict, float, tree_path, "Extrude._StartDepth"))
                    if indent:
                        print(f"{indent} StepFile: {step_file}")
                        print(f"{indent} _Contour: {bool}")
                        print(f"{indent} _Depth: {depth}")
                        print(f"{indent} _FinalDepth: {final_depth}")
                        print(f"{indent} _StartDepth: {start_depth}")
                        print(f"{indent} _StepDown: {step_down}")

                    profile.setExpression('StepDown', None)
                    profile.StepDown = step_down
                    profile.setExpression('StartDepth', None)
                    profile.StartDepth = start_depth
                    profile.setExpression('FinalDepth', None)
                    profile.FinalDepth = final_depth
                else:
                    pass  # Do process_json() here.

                profile.processHoles = False
                profile.processPerimeter = True
                profile.ToolController = tool_controller

                profile.recompute()

                # To generate a list of documented properties to "doc_file_name*:
                if False:
                    documented_properties: Tuple[str, ...] = (
                        "Active", "AreaParams", "AttemptInverseAngle", "Base", "ClearanceHeight",
                        "Comment", "CoolantMode", "CycleTime", "Direction", "EnableRotation",
                        "ExpandProfile", "ExpandProfileStepOver", "ExpressionEngine", "FinalDepth",
                        "HandleMultipleFeatures", "InverseAngle", "JoinType", "Label", "Label2",
                        "LimitDepthToFace", "MiterLimit", "OffsetExtra", "OpFinalDepth",
                        "OpStartDepth", "OpStockZMax", "OpStockZMin", "OpToolDiameter", "Path",
                        "PathParams", "Placement", "Proxy", "ReverseDirection", "SafeHeight",
                        "Side", "StartDepth", "StartPoint", "StepDown", "ToolController",
                        "UseComp", "UseStartPoint", "UserLabel", "Visibility",
                    )
                    undocumented_properties: Tuple[str, ...] = (
                        "Content", "Document", "FullName", "ID", "InList", "InListRecursive",
                        "MemSize", "Module", "MustExecute", "Name", "NoTouch", "OldLabel",
                        "OutList", "OutListRecursive", "Parents", "PropertiesList", "Removing",
                        "State", "TypeId", "ViewObject",
                    )
                    _ = undocumented_properties

                    doc_file_name: str = "/tmp/contour.md"
                    doc_file: IO[str]
                    with open(doc_file_name, "w") as doc_file:
                        property: str
                        doc_file.write("# Contour Properites\n\n")
                        for property in documented_properties:
                            doc_file.write(f"* {property} ({repr(getattr(profile, property))}): "
                                           f"{profile.getDocumentationOfProperty(property)}\n")

        if tracing:
            print(f"{tracing}<=FabCQtoFC.process_extrude(*, '{label}', {tree_path})")

    # FabCQtFC.get_common_properties():
    def get_common_properties(self) -> Dict[str, Any]:
        """Return some common properties to ignore."""
        return {}

    # FabCQtFC.get_extrude_properties():
    def get_extrude_properties(self) -> Dict[str, Any]:
        """Return the pocket properties."""
        pocket_properties: Dict[str, Any] = {
            "Active": {"ignore": None},
            "AdaptivePocketFinish": {"ignore": None},
            "AdaptivePocketStart": {"ignore": None},
            "AreaParams": {"ignore": None},
            "Base": {"ignore": None},
            "ClearanceHeight": {"type": float},
            "Comment": {"ignore": None},
            "CoolantMode": {},
            "CutMode": {},
            "CycleTime": {"ignore": None},
            "EnableRotation": {"ignore": None},
            "ExpressionEngine": {"ignore": None},
            "ExtraOffset": {"ignore": None},
            "FinalDepth": {"type": float},
            "FinishDepth": {"type": float},
            "HandleMultipleFeatures": {"ignore": None},
            "KeepToolDown": {},
            "Label": {"ignore": None},
            "Label2": {"ignore": None},
            "MinTravel": {},
            "OffsetPattern": {},
            "OpFinalDepth": {"ignore": None},
            "OpStartDepth": {"ignore": None},
            "OpStockZMax": {"ignore": None},
            "OpStockZMin": {"ignore": None},
            "OpToolDiameter": {"ignore": None},
            "Path": {"ignore": None},
            "PathParams": {"ignore": None},
            "Placement": {"ignore": None},
            "ProcessStockArea": {"ignore": None},
            "Proxy": {"ignore": None},
            "SafeHeight": {"type": float},
            "StartAt": {},
            "StartDepth": {"type": float},
            "StartPoint": {"ignore": None},
            "Step": {"extra": None},
            "StepDown": {"type": float},
            "StepOver": {},
            "ToolController": {"ignore": None},
            "UseStartPoint": {"ignore": None},
            "UserLabel": {"ignore": None},
            "Visibility": {"ignore": None},
            "ZigZagAngle": {},
            "removalshape": {"ignore": None},
        }
        return pocket_properties

    # FabCQtFC.get_pocket_properties():
    def get_pocket_properties(self) -> Dict[str, Any]:
        """Return the pocket properties."""
        pocket_properties: Dict[str, Any] = {
            "Active": {"ignore": None},
            "AdaptivePocketFinish": {"ignore": None},
            "AdaptivePocketStart": {"ignore": None},
            "AreaParams": {"ignore": None},
            "Base": {"ignore": None},
            "ClearanceHeight": {"type": float},
            "Comment": {"ignore": None},
            "CoolantMode": {},
            "CutMode": {},
            "CycleTime": {"ignore": None},
            "EnableRotation": {"ignore": None},
            "ExpressionEngine": {"ignore": None},
            "ExtraOffset": {"ignore": None},
            "FinalDepth": {"type": float},
            "FinishDepth": {"type": float},
            "HandleMultipleFeatures": {"ignore": None},
            "KeepToolDown": {},
            "Label": {"ignore": None},
            "Label2": {"ignore": None},
            "MinTravel": {},
            "OffsetPattern": {},
            "OpFinalDepth": {"ignore": None},
            "OpStartDepth": {"ignore": None},
            "OpStockZMax": {"ignore": None},
            "OpStockZMin": {"ignore": None},
            "OpToolDiameter": {"ignore": None},
            "Path": {"ignore": None},
            "PathParams": {"ignore": None},
            "Placement": {"ignore": None},
            "ProcessStockArea": {"ignore": None},
            "Proxy": {"ignore": None},
            "SafeHeight": {"type": float},
            "StartAt": {},
            "StartDepth": {"type": float},
            "StartPoint": {"ignore": None},
            "Step": {"extra": None},
            "StepDown": {"type": float},
            "StepOver": {},
            "ToolController": {"ignore": None},
            "UseStartPoint": {"ignore": None},
            "UserLabel": {"ignore": None},
            "Visibility": {"ignore": None},
            "ZigZagAngle": {},
            "removalshape": {"ignore": None},
        }
        return pocket_properties

    # FabCQtoFC.process_pocket():
    def process_pocket(self, json_dict: Dict[str, Any], label: str,
                       indent: str, tree_path: Tuple[str, ...], tracing: str = "") -> None:
        """Process a Pocket JSON node."""
        next_tracing: str = tracing + " " if tracing else ""
        if tracing:
            print(f"{tracing}=>FabCQtoFC.process_pocket(*, '{label}', {tree_path})")

        # Grab *pocket_bottom* from STEP file and insert into *project_document*:
        project_document: Any = self.ProjectDocument
        if tracing:
            print(f"{tracing}{project_document=} {project_document.Label=}")
        step = cast(str, self.key_verify(
            "StepFile", json_dict, str, tree_path, "Pocket.StepFile"))
        step_file: FilePath = FilePath(step)
        if tracing:
            print(f"{tracing}{step_file=}")
        if not step_file.exists():
            raise RuntimeError(f"{step_file} does not exits.")
        FCImport.insert(step, project_document.Label)
        pocket_label: str = (
            f"{self.CurrentSolidName}__{self.CurrentJobName}__{label}__pocket_bottom")
        if tracing:
            print(f"{tracing}{pocket_label=}")
        pocket_bottom: Any = project_document.getObject(pocket_label)
        if tracing:
            print(f"{tracing}{pocket_bottom=}")

        tool: Any = None
        tool_controller: Any = None
        tool, tool_controller = self.get_tool_and_controller(
            json_dict, label, indent, tree_path, tracing=next_tracing)
        App.ActiveDocument = project_document  # TODO: This should not be necessary
        if tracing:
            print(f"{tracing}{tool=} {tool_controller=}")

        # Now create a PathPocket object:
        pocket: Any = PathPocket.Create(pocket_label)  # => "Path::FeaturePython".

        normal: Vector = Vector(0.0, 0.0, 1.0)
        aligned_face_name: str = self.get_aligned_face_name(
            pocket_bottom, normal, tracing=next_tracing)
        # print(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
        # property_name: str
        # index: int
        # for index, property_name in enumerate(pocket.PropertiesList):
        #     enumerations: Optional[List[str]]
        #     enumerations = pocket.getEnumerationsOfProperty(property_name)
        #     if isinstance(enumerations, list):
        #         enumerations = tuple(sorted(enumerations))
        #     print(f"[{index}]: {property_name}: "
        #           f"{pocket.getDocumentationOfProperty(property_name)}:: {enumerations}")

        # [How to find Pockets in FreeCAD using Python Script?]
        #   (https://forum.freecad.org/viewtopic.php?f=22&p=579798)

        pocket.Base = (pocket_bottom, aligned_face_name)
        pocket_properties: Dict[str, Any] = self.get_pocket_properties()
        self.process_json(json_dict, pocket, pocket_properties, tracing=next_tracing)
        pocket.recompute()

        if tracing:
            print(f"{tracing}<=FabCQtoFC.process_pocket(*, '{label}', {tree_path})")

    # FabCQtoFC.process_mount():
    def process_mount(self, json_dict: Dict[str, Any], label: str,
                      indent: str, tree_path: Tuple[str, ...], tracing: str = "") -> None:
        """Process a Mount JSON node."""

        if tracing:
            print(f"{tracing}=>FabCQtotFC.process_mount(*, {label}, {tree_path})")
        contact_list: List[float] = cast(
            list, self.key_verify("_Contact", json_dict, list, tree_path, "Solid._Contact"))
        normal_list: List[float] = cast(
            list, self.key_verify("_Normal", json_dict, list, tree_path, "Solid._Normal"))
        orient_list: List[float] = cast(
            list, self.key_verify("_Orient", json_dict, list, tree_path, "Solid._Orient"))
        contact: Vector = Vector(contact_list)
        normal = Vector(normal_list)
        orient: Vector = Vector(orient_list)
        if indent:
            print(f"{indent} _Contact: {contact}")
            print(f"{indent} _Normal: {normal}")
            print(f"{indent} _Orient: {orient}")

        self.flush_job()  # Force previous job to be done.

        # Create the new job:
        job = PathJob.Create('Job', [self.CurrentPart], None)

        # TODO: Create a setupsheet and install it into the job.
        # setup_sheet: PathSetupSheet.SetupSheet = PathSetupSheet.Create()
        # job.SetupSheet = setup_sheet
        job_name: str = f"{self.CurrentPart.Label}_{label}"
        gcode_path: str = f"/tmp/{job_name}.ngc"
        job.PostProcessorOutputFile = gcode_path
        job.PostProcessor = 'grbl'
        job.PostProcessorArgs = '--no-show-editor'
        job.Label = job_name
        self.CurrentJob = job
        self.CurrentJobName = label
        self.CurrentNormal = normal

        if App.GuiUp:  # type: ignore
            proxy: Any = PathJobGui.ViewProvider(job.ViewObject)
            # The statement below causes a bunch of rearrangement of the FreeCAD
            # object tree to push all off the Path related object to be under the
            # FreeCAD Path Job object.  This is really nice because it provides
            # the ability toggle the path trace visibility in one place.  The lovely
            # line below triggers a call to  PathJob.ObjectJob.__set__state__() method.
            # Which appears to do the rearrangement.  Unfortunately, this rearrangement
            # does not occur in embedded mode, so the resulting object trees look
            # quite different.  This is the FreeCAD way.
            job.ViewObject.Proxy = proxy  # This assignment rearranges the Job.

        if tracing:
            print(f"{tracing}<=FabCQtotFC.process_mount(*, {label}, {tree_path})")

    # CQtoFC.process_solid():
    def process_solid(self, json_dict: Dict[str, Any], label: str,
                      indent: str, tree_path: Tuple[str, ...], tracing: str = "") -> None:
        """Process a Solid JSON node."""
        if tracing:
            print(f"{tracing}=>FabCQtotFC.process_solid(*, {label}, {tree_path})")

        step_file: str = cast(str, self.key_verify("StepFile",
                                                   json_dict, str, tree_path, "Solid.StepFile"))
        if indent:
            print(f"{indent} StepFile: {step_file}")

        # This code currently trys to work with object in a seperate *steps_document* and
        # the main *project_document*.  Change the conditional to switch between.
        use_project_document: bool = True
        document: Any = self.ProjectDocument if use_project_document else self.StepsDocument
        before_size: int = len(document.RootObjects)
        FCImport.insert(step_file, document.Label)
        after_size: int = len(document.RootObjects)
        assert before_size + 1 == after_size, (before_size, after_size)
        part: Any = document.getObject(label)
        part.Label = f"{label}_Step"
        step_object: Any = document.RootObjects[before_size]
        step_object.Label = label

        # When the STEP files are colocated with the assemblies and such, the visibiliy
        # of the associated *gui_step_object* needs to be disabled.
        if use_project_document and App.GuiUp:  # type: ignore
            gui_document: Any = Gui.getDocument(document.Label)  # type: ignore
            gui_step_object: Any = gui_document.getObject(label)
            gui_step_object.Visibility = False

        # Install *link* into *group*.  Complete the link later on using *pending_links*:
        link: Any = self.CurrentGroup.newObject("App::Link", label)
        self.PendingLinks.append((link, part))

        self.CurrentSolidName = label
        self.CurrentPart = part
        self.CurrentLink = link
        self.CurrentJob = None
        self.CurrentNormal = None

        if tracing:
            print(f"{tracing}<=FabCQtotFC.process_solid(*, {label}, {tree_path})")

    # CQtoFC.get_aligned_face_name():
    def get_aligned_face_name(self, obj: Any, normal: Vector, tracing: str = "") -> str:
        """Return top faces."""
        if tracing:
            print(f"{tracing}=>get_aligned_face_name({obj}, {normal})")
        assert hasattr(obj, "Shape")
        shape = obj.Shape
        face_index: int
        epsilon: float = 1.0e-8
        largest_area: float = 0.0
        largest_face_name: str = ""
        for face_index in range(len(shape.Faces)):
            face_name: str = f"Face{face_index+1}"
            face: Any = shape.getElement(face_name)
            if face.Orientation == 'Forward':
                delta: Vector = face.Surface.Axis - normal
                length: float = delta.Length
                if length < epsilon:
                    area = face.Area
                    if area > largest_area:
                        largest_area = area
                        largest_face_name = face_name
        if tracing:
            print(f"{tracing}<=get_aligned_faces_name({obj}, {normal})=>{largest_face_name}")
        return largest_face_name


# main():
def main(tracing: str = "") -> None:
    """The main program."""
    next_tracing: str = tracing + " " if tracing else ""
    if tracing:
        print(f"{tracing}=>main()")
    environ = cast(Dict[str, str], os.environ)
    json_file_name: str = environ["JSON"] if "JSON" in environ else "/tmp/TestProject.json"
    flags: str = environ["FLAGS"] if "FLAGS" in environ else ""
    cnc: bool = "c" in flags
    visual: bool = "v" in flags
    tools_path: Optional[Path] = FilePath(".") / "Tools" if cnc else None
    if tracing:
        print(f"{tracing}{json_file_name=} {tools_path=} {flags=} {cnc=} {visual=}")
    json_reader: FabCQtoFC = FabCQtoFC(FilePath(json_file_name), tools_path, cnc)
    json_reader.process(indent="  ", tracing=next_tracing)
    if not App.GuiUp:  # type: ignore
        if tracing:
            print(f"{tracing}calling sys.exit()")
        sys.exit(0)
    if tracing:
        print(f"{tracing}<=main()")


if __name__ == "__main__":
    main(tracing=" ")
