#!/usr/bin/env python3
"""CQtoFC: A module for reading CadQuery generated STEP files into FreeCAD.

This shell script converts the JSON file (.json) and associated STEP (.stp) files generated by
Fab Project into FreeCAD document files (.FCStd) and optionally it can generate CNC G code (.nc)
files.

This program is meant to be run by the FreeCAD Python interpreter.  Since there is no easy
way to pass command line arguments the interpreter, there is a shell file called `cq2fc.sh`
sets everything up to run in FreeCAD.  It passes arguments/optons in via Environment variables.
(Crude, but effective.)

The environment variable that are read are:

JSON: This the path to the JSON file.
CNC: If this is present, CNC G code (.nc) files are generated.

"""

# <--------------------------------------- 100 characters ---------------------------------------> #
print("Entered CQtoFC.py")

from dataclasses import dataclass, field
import json
import os
from pathlib import Path as FilePath  # The Path library uses `Path`.
import sys
import Path  # type: ignore
from typing import Any, cast, List, Dict, IO, Optional, Tuple, Union

import PathScripts.PathToolBit as PathToolBit  # type: ignore
from PathScripts import PathJob, PathProfile, PathPostProcessor, PathUtil  # type: ignore
from PathScripts import PathToolController  # type: ignore
_ = PathJob  # TODO: Remove
_ = PathProfile  # TODO: Remove
_ = PathPostProcessor  # TODO: Remove
_ = PathUtil  # TODO: Remove
_ = PathToolController  # TODO: Remove

# This causes out flake8 to think App are defined.
# It is actually present in the FreeCAD Python exectution envriorment.
if False:
    App = None

# FreeCAD has two different importers depending upon whether it is GUI mode or not.
from FreeCAD import Vector  # type: ignore
if App.GuiUp:  # type: ignore
    import FreeCADGui as Gui  # type: ignore
    from FreeCAD import ImportGui as FCImport  # type: ignore
    from PathScripts import PathJobGui  # type: ignore
    _ = PathJobGui  # TODO: Remove
else:
    from FreeCAD import Import as FCImport  # type: ignore


# FabCQtoFC:
@dataclass
class FabCQtoFC(object):
    """FabCQtoFC: Import CadQuery .step files into FreeCAD."""

    JsonPath: FilePath
    ToolsPath: Optional[FilePath]
    CNC: bool
    AllDocuments: List[Any] = field(init=False, repr=False)
    CurrentGroup: Any = field(init=False, repr=False)
    CurrentJob: Any = field(init=False, repr=False)
    CurrentJobName: Any = field(init=False, repr=False)
    CurrentLink: Any = field(init=False, repr=False)
    CurrentNormal: Any = field(init=False, repr=False)
    CurrentPart: Any = field(init=False, repr=False)
    PendingLinks: List[Tuple[Any, Any]] = field(init=False, repr=False)
    ProjectDocument: Any = field(init=False, repr=False)
    StepsDocument: Any = field(init=False, repr=False)
    ToolControllersTable: Dict[int, Any] = field(init=False, repr=False)
    ToolNumbersTable: Dict[int, Any] = field(init=False, repr=False)
    ToolsTable: Dict[str, Any] = field(init=False, repr=False)

    # FabCQtoFC.__post_init__():
    def __post_init__(self) -> None:
        """Initialize FabCQtoFC."""
        assert isinstance(self.JsonPath, FilePath), self.JsonPath
        self.AllDocuments = []
        self.CurrentGroup = None
        self.CurrentJob = None
        self.CurrentJobName = None
        self.CurrentLink = None
        self.CurrentNormal = None
        self.CurrentPart = None
        self.PendingLinks = []
        self.ProjectDocument = None
        self.StepsDocument = None
        self.ToolControllersTable = {}
        self.ToolNumbersTable = {}
        self.ToolsTable = {}

    # FabCQtoFC.fetch_tool():
    def fetch_tool(self, bit_name: str) -> Any:
        """Fetch a tool from the Tools/Bit and store into ToolsTable."""
        tools_table: Dict[str, Any] = self.ToolsTable
        if bit_name not in tools_table:
            # Create the *bit_path* file name and verify that it exists:
            assert isinstance(self.ToolsPath, FilePath), f"{type(self.ToolsPath)=}"
            bit_directory: FilePath = self.ToolsPath / "Bit"
            bit_path: FilePath = bit_directory / f"{bit_name}.fctb"
            if not bit_path.exists():
                raise RuntimeError(f"{str(bit_path)} file does not exist")

            # Read *bit_path* contents in and convert into *bit_json*:
            bit_file: IO[str]
            with open(bit_path, "r") as bit_file:
                bit_text: str = bit_file.read()
            bit_json: Any = json.loads(bit_text)

            # Convert *bit_json* into *tool* and save it:
            tool: Any = PathToolBit.Factory.CreateFromAttrs(bit_json, bit_name)
            tool.Visibility = False
            tools_table[bit_name] = tool
        return tools_table[bit_name]

    # FabCQtoFC.get_tool_and_controller():
    def get_tool_and_controller(
            self, json_dict: Dict[str, Any], label: str, indent: str, tree_path: Tuple[str, ...],
            tracing: str = "") -> Tuple[Any, Any]:
        """Extract tool controller and associated tool bit from a JSON node."""
        if tracing:
            print(f"{tracing}=>FabCQtotFC.get_tool_and_controller(*, {label}, {tree_path})")
        tool_controller_index = cast(
            int, self.key_verify("ToolControllerIndex", json_dict, int,
                                 tree_path, "get_tool_and controller.ToolControllerIndex"))
        tool_controllers_table: Dict[int, Any] = self.ToolControllersTable
        tool_controller: Any
        if tool_controller_index in tool_controllers_table:
            tool_controller = tool_controllers_table[tool_controller_index]
        else:
            # Extract the *tool_controller_dict* from *json_dict*:
            tool_controller_dict = cast(
                Dict[str, Any], self.key_verify(
                    "ToolController", json_dict, dict,
                    tree_path, "get_tool_and controller.ToolController"))

            # Extract the tool controller fields from *json_dict*:
            bit_name = cast(
                str, self.key_verify(
                    "BitName", tool_controller_dict, str,
                    tree_path, "get_tool_and controller.BitName"))
            cooling = cast(
                str, self.key_verify(
                    "Cooling", tool_controller_dict, str,
                    tree_path, "get_tool_and controller.Cooling"))
            horizontal_feed = cast(
                float, self.key_verify(
                    "HorizontalFeed", tool_controller_dict, float,
                    tree_path, "get_tool_and controller.HoriztontalFeed"))
            horizontal_rapid = cast(
                float, self.key_verify(
                    "HorizontalRapid", tool_controller_dict, float,
                    tree_path, "get_tool_and controller.HoriztontalRapid"))
            spindle_direction = cast(
                bool, self.key_verify(
                    "SpindleDirection", tool_controller_dict, bool,
                    tree_path, f"get_tool_and controller.SpindleDirection {tool_controller_dict}"))
            spindle_speed = cast(
                float, self.key_verify(
                    "SpindleSpeed", tool_controller_dict, float,
                    tree_path, "get_tool_and controller.SpindleSpeed"))
            tool_number = cast(
                int, self.key_verify(
                    "ToolNumber", tool_controller_dict, int,
                    tree_path, "get_tool_and controller.ToolNumber"))
            vertical_feed = cast(
                float, self.key_verify(
                    "VerticalFeed", tool_controller_dict, float,
                    tree_path, "get_tool_and controller.VerticalFeed"))
            vertical_rapid = cast(
                float, self.key_verify(
                    "VerticalRapid", tool_controller_dict, float,
                    tree_path, "get_tool_and controller.VerticalRapid"))
            _ = cooling  # Extremely weird, tool controllers do not cooling.

            # Create the *tool_controller*:
            tool_controller = PathToolController.Create(name=label)

            # Look up the *tool* using *tool_number* and/or *bit_name*:
            tool: Any
            if tool_number in self.ToolNumbersTable:
                tool = self.ToolNumbersTable[tool_number]
            else:
                tool = self.fetch_tool(bit_name)
                self.ToolNumbersTable[tool_number] = tool
            tool_controller.Tool = tool

            # A helper method to fill in the *tool_controller* fields:
            def tool_controller_set(tool_controller: Any, attribute_name: str,
                                    value: Union[int, str, float]) -> None:
                """Set a field value in the tool controller."""
                if hasattr(tool_controller, attribute_name):
                    # Make sure that there is no expression present for *attribute_name*.
                    # If this is not done, the following value set does not "take".
                    tool_controller.setExpression(attribute_name, None)
                    setattr(tool_controller, attribute_name, value)
                else:
                    raise RuntimeError(f"ToolController does not have Attribute {attribute_name}")

            # Load up the contents of *tool_controller*:
            tool_controller_set(tool_controller, "HorizFeed", horizontal_feed)
            tool_controller_set(tool_controller, "HorizRapid", horizontal_rapid)
            tool_controller_set(tool_controller, "SpindleDir", spindle_direction)
            tool_controller_set(tool_controller, "SpindleSpeed", spindle_speed)
            tool_controller_set(tool_controller, "ToolNumber", tool_number)
            tool_controller.Tool = tool
            tool_controller_set(tool_controller, "VertFeed", vertical_feed)
            tool_controller_set(tool_controller, "VertRapid", vertical_rapid)
            # Weird! There is to coolant field in a tool controller yet.
            tool_controllers_table[tool_controller_index] = tool_controller

        if tracing:
            print(f"{tracing}<=FabCQtotFC.get_tool_and_controller(*, {label}, {tree_path})")
        return (tool, tool_controller)

    # FabCQtoFC.flush_job(self):
    def flush_job(self, tracing: str = ""):
        if tracing:
            print("{tracing}=>FabCQtoFC.flush_job()")
        job: Any = self.CurrentJob
        job_name: Any = self.CurrentJobName
        if job:
            # Create *post_list* which is a list of tool controllers and *operations*:
            post_list: List[Any] = []
            current_tool_number: int = -99999999
            for index, operation in enumerate(job.Operations.Group):
                tool_controller: Any = PathUtil.toolControllerForOp(operation)
                tool: Any = tool_controller.Tool
                if tracing:
                    print(f"{tracing}{tool=}")
                    print(dir(tool))
                    print("")

                if tool_controller is not None:
                    if tool_controller.ToolNumber != current_tool_number:
                        post_list.append(tool_controller)
                        current_tool_number = tool_controller.ToolNumber
                post_list.append(operation)

            # Generate the gcode and output it to *gcode_path*:
            gcode_path = f"/tmp/{job_name}.ngc"
            post: Any = PathPostProcessor.PostProcessor.load(job.PostProcessor)
            post.export(post_list, gcode_path, job.PostProcessorArgs)

        self.CurrentJob = None
        self.CurrentJobName = None
        if tracing:
            print("{tracing}<=FabCQtoFC.flush_job()")

    # FabCQtoFC.process():
    def process(self, indent: str = "", tracing: str = "") -> None:
        """Process a JSON file into a FreeCAD documents."""
        next_tracing: str = tracing + "  " if tracing else ""
        if tracing:
            print(f"{tracing}=>FabCQtFC.process({str(self.JsonPath), {self.ToolsPath}})")

        # Create the *steps_document*:
        json_directory: FilePath = self.JsonPath.parent
        steps_document: Any = App.newDocument("Step_Files")  # type: ignore
        self.StepsDocument = steps_document
        self.AllDocuments.append(steps_document)

        # Read in *json_path*:
        json_file: IO[str]
        json_text: str = ""
        if self.JsonPath.suffix != ".json":
            raise RuntimeError(f"JSON file must have `.json` suffix: '{str(self.JsonPath)}'")
        if tracing:
            print(f"{tracing}Loading {str(self.JsonPath)}")
        with open(self.JsonPath, "r") as json_file:
            json_text = json_file.read()
        if tracing:
            print(f"{tracing}Parsing {str(self.JsonPath)}")
        json_root = cast(Dict[str, Any], json.loads(json_text))
        assert isinstance(json_root, dict), json_root

        # Recursively walk the tree starting at *json_root*:
        if tracing:
            print(f"{tracing}Processing {str(self.JsonPath)}")
        self.node_process(("Root",), json_root, indent=indent, tracing=next_tracing)

        # Save *all_documents*:
        document: Any
        for document in self.AllDocuments:
            save_path: FilePath = json_directory / f"{document.Label}.FCStd"
            if save_path.exists():
                save_path.unlink()
            document.recompute()
            document.saveAs(str(save_path))
        self.flush_job()

        # Install all of the *pending_links*:
        pending_link: Tuple[Any, Any]
        link: Any
        part: Any
        for link, part in self.PendingLinks:
            link.setLink(part)
        if tracing:
            print(f"{tracing}<=FabCQtFC.process({str(self.JsonPath), {self.ToolsPath}})")

    # FabCQtoFC.type_verify():
    def type_verify(self, value: Any, value_type: type,
                    tree_path: Tuple[str, ...], tag: str) -> None:
        """Verify JSON type."""
        if not isinstance(value, value_type):
            message: str = f"{tree_path}: {tag}: Got {type(value)}, not {value_type}"
            print(message)
            assert False, message

    # FabCQtoFC.key_verify():
    def key_verify(self, key: str, table: Dict[str, Any], key_type: type,
                   tree_path: Tuple[str, ...], tag: str) -> Any:
        """Verify key is in dictionary and has correct type."""
        if key not in table:
            message: str = f"{tree_path}: {tag}: '{key}' is not one of {tuple(table.keys())}'"
            print(message)
            assert False, message
        value: Any = table[key]
        self.type_verify(value, key_type, tree_path, tag)
        return value

    # FabCQtoFC.node_process():
    def node_process(self, tree_path: Tuple[str, ...], json_dict: Dict[str, Any],
                     indent: str = "", tracing: str = "") -> None:
        """Process one 'node' of JSON content."""

        # Set up *tracing* and pretty print *indent*:
        next_tracing: str = tracing + "  " if tracing else ""
        next_indent = indent + "  " if indent else ""
        if tracing:
            print(f"{tracing}=>FabCQtoFC.child_process(*, {tree_path}, '{indent}')")
            print(f"{tracing}{json_dict=}")

        # Do some sanity checking:
        error_message: str
        self.type_verify(json_dict, dict, tree_path, "json_dict")
        kind = cast(str, self.key_verify("Kind", json_dict, str, tree_path, "Kind"))
        label = cast(str, self.key_verify("Label", json_dict, str, tree_path, "Label"))
        if indent:
            print(f"{indent}{label}:")
            print(f"{indent} Kind: {kind}")

        # Verify that that *kind* is one of the *allowed_kinds*:
        allowed_kinds: Tuple[str, ...] = (
            "Project", "Document", "Assembly", "Solid", "Mount",
            "Extrude", "Pocket", "Drill")
        if kind not in allowed_kinds:
            error_message = f"{tree_path}: Node kind '{kind}' not one of {allowed_kinds}"
            print(error_message)
            assert False, error_message

        # Dispatch on *kind*:
        if kind == "Project":
            pass
        elif kind == "Document":
            self.process_document(json_dict, label, indent, tree_path, tracing=next_tracing)
        elif kind == "Assembly":
            self.process_assembly(json_dict, label, indent, tree_path, tracing=next_tracing)
        elif kind == "Solid":
            self.process_solid(json_dict, label, indent, tree_path, tracing=next_tracing)
        elif kind == "Mount":
            self.process_mount(json_dict, label, indent, tree_path, tracing=next_tracing)
        elif kind == "Extrude":
            self.process_extrude(json_dict, label, indent, tree_path, tracing=next_tracing)
        elif kind == "Pocket":
            self.process_pocket(json_dict, label, indent, tree_path, tracing=next_tracing)
        else:
            message = f"{kind} not one of {allowed_kinds}"
            print(message)
            assert False, message

        # Recursively process any *chidren* JSON nodes:
        if "children" in json_dict:
            children = cast(List[Dict[str, Any]],
                            self.key_verify("children", json_dict, list, tree_path, "Children"))
            if indent:
                print(f"{indent} children ({len(children)}):")

            child_dict: Dict[str, Any]
            for child_dict in children:
                self.type_verify(child_dict, dict, tree_path, "Child")
                child_name = cast(str,
                                  self.key_verify("Label", child_dict, str, tree_path, "Label"))
                child_tree_path: Tuple[str, ...] = tree_path + (child_name,)
                self.node_process(child_tree_path, child_dict,
                                  indent=next_indent, tracing=next_tracing)
        if tracing:
            print(f"{tracing}<=FabCQtoFC.child_process({tree_path}, '{indent}')")

    # FabCQtoFC.process_assembly():
    def process_assembly(self, json_dict: Dict[str, Any], label: str,
                         indent: str, tree_path: Tuple[str, ...], tracing: str = "") -> None:
        if tracing:
            print(f"{tracing}=>FabCQtoFC.process_assembly(*, '{label}', {tree_path})")
        if self.CurrentGroup:
            self.CurrentGroup = self.CurrentGroup.newObject("App::DocumentObjectGroup", label)
        else:
            self.CurrentGroup = self.ProjectDocument.addObject("App::DocumentObjectGroup", label)
        if tracing:
            print(f"{tracing}<=FabCQtoFC.process_assembly(*, '{label}', {tree_path})")

    # FabCQtoFC.process_document():
    def process_document(self, json_dict: Dict[str, Any], label: str,
                         indent: str, tree_path: Tuple[str, ...], tracing: str = "") -> None:
        """Process a Document JSON node."""
        # next_tracing: str = tracing + " " if tracing else ""
        if tracing:
            print(f"{tracing}=>FabCQtoFC.process_document(*, '{label}', {tree_path})")
        file_path: str = cast(str, self.key_verify(
            "_FilePath", json_dict, str, tree_path, "Document._File_Path"))
        project_document = App.newDocument(label)  # type: ignore
        project_document.Label = label
        if indent:
            print(f"{indent} _FilePath: {file_path}")
            self.ProjectDocument = project_document
            self.AllDocuments.append(project_document)
        if tracing:
            print(f"{tracing}<=FabCQtoFC.process_document(*, '{label}', {tree_path})")

    # FabCQtoFC.process_extrude():
    def process_extrude(self, json_dict: Dict[str, Any], label: str,
                        indent: str, tree_path: Tuple[str, ...], tracing: str = "") -> None:
        """Process an Extrude JSON node."""
        next_tracing: str = tracing + " " if tracing else ""
        if tracing:
            print(f"{tracing}=>FabCQtoFC.process_extrude(*, '{label}', {tree_path})")
        contour = cast(bool, self.key_verify("_Contour", json_dict, bool, tree_path,
                                             "Extrude._Contour"))
        depth = cast(float, self.key_verify("_Depth", json_dict, float, tree_path,
                                            "Extrude._Depth"))
        final_depth = cast(float, self.key_verify("_FinalDepth", json_dict, float, tree_path,
                                                  "Extrude._FinalDepth"))
        step_down = cast(float, self. key_verify("_StepDown", json_dict, float, tree_path,
                                                 "Extrude._StepDown"))
        step_file = cast(str, self.key_verify("_StepFile", json_dict, str, tree_path,
                                              "Extrude._StepFile"))
        start_depth = cast(float, self.key_verify("_StartDepth", json_dict, float, tree_path,
                                                  "Extrude._StartDepth"))
        if indent:
            print(f"{indent} _Contour: {bool}")
            print(f"{indent} _Depth: {depth}")
            print(f"{indent} _FinalDepth: {final_depth}")
            print(f"{indent} _StartDepth: {start_depth}")
            print(f"{indent} _StepDown: {step_down}")
            print(f"{indent} _StepFile: {step_file}")

        def get_aligned_face_name(obj: Any, normal: Vector, tracing: str = "") -> str:
            """Return top faces."""
            if tracing:
                print(f"{tracing}=>get_aligned_face_name({obj}, {normal})")
            assert hasattr(obj, "Shape")
            shape = obj.Shape
            face_index: int
            epsilon: float = 1.0e-8
            largest_area: float = 0.0
            largest_face_name: str = ""
            for face_index in range(len(shape.Faces)):
                face_name: str = f"Face{face_index+1}"
                face: Any = shape.getElement(face_name)
                if face.Orientation == 'Forward':
                    delta: Vector = face.Surface.Axis - normal
                    length: float = delta.Length
                    if length < epsilon:
                        area = face.Area
                        if area > largest_area:
                            largest_area = area
                            largest_face_name = face_name
            if tracing:
                print(f"{tracing}<=get_aligned_faces_name({obj}, {normal})=>{largest_face_name}")
            return largest_face_name

        def do_contour(obj: Any, name: str, job: Any, normal: Vector,
                       start_depth: float, step: float, final_depth: float,
                       tool_controller: Any, tracing: str = "") -> Any:
            """Create an exterior contour."""
            next_tracing: str = tracing + " " if tracing else ""
            if tracing:
                print(f"{tracing}=>contour({obj=}, {name=}, {job=}, {normal=})")
            aligned_face_name: str = get_aligned_face_name(obj, normal, tracing=next_tracing)
            if aligned_face_name:
                if tracing:
                    print(f"{tracing}Create profile")
                # This prints:
                # PathSetupSheet.INFO: SetupSheet has no support for TestSolid_Step_Top_profile
                profile = PathProfile.Create(name)
                if tracing:
                    print(f"{tracing}profile created")
                profile.Base = (obj, aligned_face_name)
                profile.setExpression('StepDown', None)
                profile.StepDown = step_down
                profile.setExpression('StartDepth', None)
                profile.StartDepth = start_depth
                profile.setExpression('FinalDepth', None)
                profile.FinalDepth = final_depth
                profile.processHoles = False
                profile.processPerimeter = True
                profile.ToolController = tool_controller
                profile.recompute()

                # To generate a list of documented properties to "doc_file_name*:
                if False:
                    documented_properties: Tuple[str, ...] = (
                        "Active", "AreaParams", "AttemptInverseAngle", "Base", "ClearanceHeight",
                        "Comment", "CoolantMode", "CycleTime", "Direction", "EnableRotation",
                        "ExpandProfile", "ExpandProfileStepOver", "ExpressionEngine", "FinalDepth",
                        "HandleMultipleFeatures", "InverseAngle", "JoinType", "Label", "Label2",
                        "LimitDepthToFace", "MiterLimit", "OffsetExtra", "OpFinalDepth",
                        "OpStartDepth", "OpStockZMax", "OpStockZMin", "OpToolDiameter", "Path",
                        "PathParams", "Placement", "Proxy", "ReverseDirection", "SafeHeight",
                        "Side", "StartDepth", "StartPoint", "StepDown", "ToolController",
                        "UseComp", "UseStartPoint", "UserLabel", "Visibility",
                    )
                    undocumented_properties: Tuple[str, ...] = (
                        "Content", "Document", "FullName", "ID", "InList", "InListRecursive",
                        "MemSize", "Module", "MustExecute", "Name", "NoTouch", "OldLabel",
                        "OutList", "OutListRecursive", "Parents", "PropertiesList", "Removing",
                        "State", "TypeId", "ViewObject",
                    )
                    _ = undocumented_properties

                    doc_file_name: str = "/tmp/contour.md"
                    doc_file: IO[str]
                    with open(doc_file_name, "w") as doc_file:
                        property: str
                        doc_file.write("# Contour Properites\n\n")
                        for property in documented_properties:
                            doc_file.write(f"* {property} ({repr(getattr(profile, property))}): "
                                           f"{profile.getDocumentationOfProperty(property)}\n")

            if tracing:
                print(f"{tracing}<=contour()=>{profile}")
            return profile

        if tracing:
            print(f"{tracing}Creating job")
        job = self.CurrentJob
        normal = self.CurrentNormal
        assert job is not None, "No job present"

        if contour:
            tool_controller: Any = None
            _, tool_controller = self.get_tool_and_controller(
                json_dict, label, indent, tree_path, tracing=next_tracing)
            do_contour(self.CurrentPart, f"{job.Label}_profile", job, normal,
                       start_depth, step_down, final_depth, tool_controller, tracing=next_tracing)

        if tracing:
            print(f"{tracing}<=FabCQtoFC.process_extrude(*, '{label}', {tree_path})")

    # FabCQtoFC.process_pocket():
    def process_pocket(self, json_dict: Dict[str, Any], label: str,
                       indent: str, tree_path: Tuple[str, ...], tracing: str = "") -> None:
        """Process a Pocket JSON node."""
        if tracing:
            print(f"{tracing}=>FabCQtoFC.process_pocket(*, '{label}', {tree_path})")

        cut_mode = cast(str, self.key_verify("_CutMode", json_dict, str, tree_path,
                                             "Pocket._CutMode"))
        extra_offset = cast(float, self.key_verify("_ExtraOffset", json_dict, float, tree_path,
                                                   "Pocket._ExtraOffset"))
        keep_tool_down = cast(bool, self.key_verify("_KeepToolDown", json_dict, bool, tree_path,
                                                    "Pocket._KeepToolDown"))
        min_travel = cast(float, self. key_verify("_MinTravel", json_dict, float, tree_path,
                                                  "Pocket._MinTravel"))
        offset_pattern = cast(str, self.key_verify("_OffsetPattern", json_dict, str, tree_path,
                                                   "Pocket._OffsetPattern"))
        start_at = cast(str, self.key_verify("_StartAt", json_dict, str, tree_path,
                                             "Pocket._StartAt"))
        step = cast(str, self.key_verify("_Step", json_dict, str, tree_path,
                                         "Pocket._Step"))
        step_over = cast(float, self.key_verify("_StepOver", json_dict, float, tree_path,
                                                "Pocket._StepOver"))
        zig_zag_angle = cast(float, self.key_verify("_ZigZagAngle", json_dict, float, tree_path,
                                                    "Pocket._ZigZagAngle"))
        cut_modes: Tuple[str, ...] = ("CW", "CCW")
        if cut_mode not in cut_modes:
            raise RuntimeError("Pocket._CutMode is '{cut_mode}', not one of {cut_modes}")
        offset_patterns: Tuple[str, ...] = (
            "ZigZag", "Offset", "Spiral", "ZigZagOffset", "Line", "Grid", "Triangle")
        if offset_pattern not in offset_patterns:
            raise RuntimeError(
                "Pocket._OffsetPattern is '{offset_pattern}', not one of {offset_patterns}")
        start_ats: Tuple[str, ...] = ("Center", "Edge")
        if start_at not in start_ats:
            raise RuntimeError(
                "Pocket._StartAt is '{start_at}', not one of {start_ats}")

        if indent:
            print(f"{indent} _CutMode: '{cut_mode}'")
            print(f"{indent} _ExtraOffset: {extra_offset}")
            print(f"{indent} _KeepToolDown: {keep_tool_down}")
            print(f"{indent} _MinTravel: {min_travel}")
            print(f"{indent} _OffsetPattern: '{offset_pattern}'")
            print(f"{indent} _StartAt: {start_at}")
            print(f"{indent} _Step: '{step}'")
            print(f"{indent} _StepOver: {step_over}")
            print(f"{indent} _ZigZagAngle: {zig_zag_angle}")

        # project_document: Any = self.ProjectDocument
        # step_file: FilePath = FilePath(step)
        # if not step_file.exists():
        #     raise RuntimeError(f"{step_file} does not exits.")
        # foo: Any = FCImport(step, project_document.Label)  #
        # print(f"{dir(foo)=}")
        # pocket_part: Any = project_document.getObject(pocket_label)
        # _ = pocket_part
        # assert False

        # Now create a PathPocket object:
        # pocket_label: str = "label"
        # assert project_document.Label == "TestDocument"  # TODO: Remove
        # App.ActiveDocument = project_document  # TODO: This should not be necessary
        # FCImport.insert(step, project_document.Label)
        # pocket_part: Any = project_document.getObject(pocket_label)
        # _ = pocket_part

        # obj = PathPocket.Create() => "Path::FeaturePython".
        # obj.Proxy == ObjectPyhon(obj, name)  # obj is the imported step file?

        if tracing:
            print(f"{tracing}<=FabCQtoFC.process_pocket(*, '{label}', {tree_path})")

    # FabCQtoFC.process_mount():
    def process_mount(self, json_dict: Dict[str, Any], label: str,
                      indent: str, tree_path: Tuple[str, ...], tracing: str = "") -> None:
        """Process a Mount JSON node."""

        if tracing:
            print(f"{tracing}=>FabCQtotFC.process_mount(*, {label}, {tree_path})")
        contact_list: List[float] = cast(
            list, self.key_verify("_Contact", json_dict, list, tree_path, "Solid._Contact"))
        normal_list: List[float] = cast(
            list, self.key_verify("_Normal", json_dict, list, tree_path, "Solid._Normal"))
        orient_list: List[float] = cast(
            list, self.key_verify("_Orient", json_dict, list, tree_path, "Solid._Orient"))
        contact: Vector = Vector(contact_list)
        normal = Vector(normal_list)
        orient: Vector = Vector(orient_list)
        if indent:
            print(f"{indent} _Contact: {contact}")
            print(f"{indent} _Normal: {normal}")
            print(f"{indent} _Orient: {orient}")

        self.flush_job()  # Force previous job to be done.

        # Create the new job:
        job = PathJob.Create('Job', [self.CurrentPart], None)

        # TODO: Create a setupsheet and install it into the job.
        # setup_sheet: PathSetupSheet.SetupSheet = PathSetupSheet.Create()
        # job.SetupSheet = setup_sheet
        job_name: str = f"{self.CurrentPart.Label}_{label}"
        gcode_path: str = f"/tmp/{job_name}.ngc"
        job.PostProcessorOutputFile = gcode_path
        job.PostProcessor = 'grbl'
        job.PostProcessorArgs = '--no-show-editor'
        job.Label = job_name
        self.CurrentJob = job
        self.CurrentJobName = label
        self.CurrentNormal = normal

        if App.GuiUp:  # type: ignore
            proxy: Any = PathJobGui.ViewProvider(job.ViewObject)
            # The statement below causes a bunch of rearrangement of the FreeCAD
            # object tree to push all off the Path related object to be under the
            # FreeCAD Path Job object.  This is really nice because it provides
            # the ability toggle the path trace visibility in one place.  The lovely
            # line below triggers a call to  PathJob.ObjectJob.__set__state__() method.
            # Which appears to do the rearrangement.  Unfortunately, this rearrangement
            # does not occur in embedded mode, so the resulting object trees look
            # quite different.  This is the FreeCAD way.
            job.ViewObject.Proxy = proxy  # This assignment rearranges the Job.

        if tracing:
            print(f"{tracing}<=FabCQtotFC.process_mount(*, {label}, {tree_path})")

    # CQtoFC.process_solid():
    def process_solid(self, json_dict: Dict[str, Any], label: str,
                      indent: str, tree_path: Tuple[str, ...], tracing: str = "") -> None:
        """Process a Solid JSON node."""
        if tracing:
            print(f"{tracing}=>FabCQtotFC.process_solid(*, {label}, {tree_path})")

        step_file: str = cast(str, self.key_verify("_Step",
                                                   json_dict, str, tree_path, "Solid._step"))
        if indent:
            print(f"{indent} _Step: {step_file}")

        # This code currently trys to work with object in a seperate *steps_document* and
        # the main *project_document*.  Change the conditional to switch between.
        use_project_document: bool = True
        document: Any = self.ProjectDocument if use_project_document else self.StepsDocument
        before_size: int = len(document.RootObjects)
        FCImport.insert(step_file, document.Label)
        after_size: int = len(document.RootObjects)
        assert before_size + 1 == after_size, (before_size, after_size)
        part: Any = document.getObject(label)
        part.Label = f"{label}_Step"
        step_object: Any = document.RootObjects[before_size]
        step_object.Label = label

        # When the STEP files are colocated with the assemblies and such, the visibiliy
        # of the associated *gui_step_object* needs to be disabled.
        if use_project_document and App.GuiUp:  # type: ignore
            gui_document: Any = Gui.getDocument(document.Label)  # type: ignore
            gui_step_object: Any = gui_document.getObject(label)
            gui_step_object.Visibility = False

        # Install *link* into *group*.  Complete the link later on using *pending_links*:
        link: Any = self.CurrentGroup.newObject("App::Link", label)
        self.PendingLinks.append((link, part))

        self.CurrentPart = part
        self.CurrentLink = link
        self.CurrentJob = None
        self.CurrentNormal = None

        if tracing:
            print(f"{tracing}<=FabCQtotFC.process_solid(*, {label}, {tree_path})")


# main():
def main(tracing: str = "") -> None:
    """The main program."""
    next_tracing: str = tracing + " " if tracing else ""
    if tracing:
        print(f"{tracing}=>main()")
    environ = cast(Dict[str, str], os.environ)
    json_file_name: str = environ["JSON"] if "JSON" in environ else "/tmp/TestProject.json"
    flags: str = environ["FLAGS"] if "FLAGS" in environ else ""
    cnc: bool = "c" in flags
    visual: bool = "v" in flags
    tools_path: Optional[Path] = FilePath(".") / "Tools" if cnc else None
    if tracing:
        print(f"{tracing}{json_file_name=} {tools_path=} {flags=} {cnc=} {visual=}")
    json_reader: FabCQtoFC = FabCQtoFC(FilePath(json_file_name), tools_path, cnc)
    json_reader.process(indent="  ", tracing=next_tracing)
    if not App.GuiUp:  # type: ignore
        if tracing:
            print(f"{tracing}calling sys.exit()")
        sys.exit(0)
    if tracing:
        print(f"{tracing}<=main()")


if __name__ == "__main__":
    main(tracing=" ")
