#!/usr/bin/env python3
"""CQtoFC: A module for reading CadQuery generated STEP files into FreeCAD.

This shell script converts the JSON file (.json) and associated STEP (.stp) files generated by
Fab Project into FreeCAD document files (.FCStd) and optionally it can generate CNC G code (.nc)
files.

This program is meant to be run by the FreeCAD Python interpreter.  Since there is no easy
way to pass command line arguments the interpreter, there is a shell file called `cq2fc.sh`
sets everything up to run in FreeCAD.  It passes arguments/optons in via Environment variables.
(Crude, but effective.)

The environment variable that are read are:

JSON: This the path to the JSON file.
CNC: If this is present, CNC G code (.nc) files are generated.

"""

# <--------------------------------------- 100 characters ---------------------------------------> #

from dataclasses import dataclass, field
import json
import os
from pathlib import Path
import sys
from typing import Any, cast, List, Dict, IO, Tuple

# Freecad has two different importers depending upon whether it is GUI mode or not.
if App.GuiUp:  # type: ignore
    from FreeCAD import ImportGui as FCImport  # type: ignore
else:
    from FreeCAD import Import as FCImport  # type ignore


# FabCQtoFC:
@dataclass
class FabCQtoFC(object):
    """FabCQtoFC: Import CadQuery .step files into FreeCAD."""

    json_path: Path
    cnc: bool
    steps_document: Any = field(init=False, repr=False)
    project_document: Any = field(init=False, repr=False)
    all_documents: List[Any] = field(init=False, repr=False)
    pending_links: List[Tuple[Any, Any]] = field(init=False, repr=False)

    # FabCQtoFC.__post_init__():
    def __post_init__(self) -> None:
        """Initialize FabCQtoFC."""
        assert isinstance(self.json_path, Path), self.json_path
        self.steps_document = None
        self.all_documents = []
        self.pending_links = []
        self.pending_links: List[Tuple[Any, Any]] = []
        self.project_document = None

    # FabCQtoFC.process():
    def process(self, indent: str = "", tracing: str = "") -> None:
        """Process a JSON file into a FreeCAD documents."""
        next_tracing: str = tracing + "  " if tracing else ""
        if tracing:
            print(f"{tracing}=>FabCQtFC.process({str(self.json_path), {self.cnc}})")

        # Create the *steps_document*:
        json_directory: Path = self.json_path.parent
        steps_document: Any = App.newDocument("Step_Files")  # type: ignore
        self.steps_document = steps_document
        self.all_documents.append(steps_document)

        # Read in *json_path*:
        json_file: IO[str]
        json_text: str = ""
        if self.json_path.suffix != ".json":
            raise RuntimeError(f"JSON file must have `.json` suffix: '{str(self.json_path)}'")
        if tracing:
            print(f"{tracing}Loading {str(self.json_path)}")
        with open(self.json_path, "r") as json_file:
            json_text = json_file.read()
        if tracing:
            print(f"{tracing}Parsing {str(self.json_path)}")
        json_root = cast(Dict[str, Any], json.loads(json_text))
        assert isinstance(json_root, dict), json_root

        # Recursively walk the tree starting at *json_root*:
        if tracing:
            print(f"{tracing}Processing {str(self.json_path)}")
        self.node_process(("Root",), json_root, group=None, indent=indent, tracing=next_tracing)

        # Save *all_documents*:
        document: Any
        for document in self.all_documents:
            save_path: Path = json_directory / f"{document.Label}.FCStd"
            if save_path.exists():
                save_path.unlink()
            document.saveAs(str(save_path))

        # Install all of the *pending_links*:
        pending_link: Tuple[Any, Any]
        link: Any
        part: Any
        for link, part in self.pending_links:
            link.setLink(part)
        if tracing:
            print(f"{tracing}<=FabCQtFC.process({str(self.json_path), {self.cnc}})")

    # FabCQtoFC.node_process():
    def node_process(self, tree_path: Tuple[str, ...], json_dict: Dict[str, Any], group: Any,
                     indent: str = "", tracing: str = "") -> None:
        """Process one 'node' of JSON content."""
        # Set up *tracing* and pretty print *indent*:
        next_tracing: str = tracing + "  " if tracing else ""
        next_indent = indent + "  " if indent else ""
        if tracing:
            print(f"{tracing}=>FabCQtoFC.child_process(*, {tree_path}, '{indent}')")
            print(f"{tracing}{json_dict=}")

        # Do some sanity checking:
        error_message: str
        if not isinstance(json_dict, dict):
            error_message = f"{tracing}{tree_path}: json_dict: Got {type(json_dict)} not dict"
            print(error_message)
            assert False, error_message
        keys: Tuple[str, ...] = tuple(json_dict.keys())

        if "Kind" not in json_dict:
            error_message = f"{tracing}{tree_path}: 'Kind' not one of {keys}"
            print(error_message)
            assert False, error_message
        kind = cast(str, json_dict["Kind"])

        if "Label" not in json_dict:
            error_message = f"{tracing}{tree_path}: 'Label' not one of {keys}"
            print(error_message)
            assert False, error_message
        label = cast(str, json_dict["Label"])

        allowed_kinds: Tuple[str, ...] = ("Project", "Document", "Assembly", "Solid")
        if not isinstance(kind, str) and kind in allowed_kinds:
            error_message = f"{tracing}{tree_path}: Node kind '{kind}' not one of {allowed_kinds}"
            print(error_message)
            assert False, error_message

        if indent:
            print(f"{indent}{label}:")
            print(f"{indent} kind: {kind}")

        steps_document: Any = self.steps_document
        project_document: Any = self.project_document

        # Dispatch on *kind*:
        if kind == "Project":
            pass
        elif kind == "Document":
            project_document = App.newDocument(label)  # type: ignore
            project_document.Label = label
            self.project_document = project_document
            self.all_documents.append(project_document)
        elif kind == "Assembly":
            if group:
                group = group.newObject("App::DocumentObjectGroup", label)
            else:
                group = project_document.addObject("App::DocumentObjectGroup", label)
        elif kind == "Solid":
            step: str = cast(str, json_dict["_Step"])
            assert isinstance(step, str), step
            if indent:
                print(f"{indent} step: '{step}'")
            before_size: int = len(steps_document.RootObjects)
            FCImport.insert(step, steps_document.Label)
            after_size: int = len(steps_document.RootObjects)
            assert before_size + 1 == after_size, (before_size, after_size)
            part: Any = steps_document.getObject(label)
            part.Label = f"{label}_Step"
            steps_document.RootObjects[before_size].Label = label

            # Install *link* into *group*.  Complete the link later on using *pending_links*:
            link: Any = group.newObject("App::Link", label)
            self.pending_links.append((link, part))
        elif kind == "Mount":
            pass
        else:
            # assert False, kind
            pass

        self.group = group
        if tracing:
            print(f"{tracing}here 103")

        if "children" in json_dict:
            children = cast(List[List[Any]], json_dict["children"])
            if not isinstance(children, list):
                error_message = f"{tracing}{tree_path}: children: Got {type(children)}, not dict"
                print(error_message)
                assert False, error_message
            if indent:
                print(f"{indent} children ({len(children)}):")

            child: Any
            for child in children:
                child_dict = cast(Dict[str, Any], child)
                if not isinstance(child_dict, dict):
                    error_message = (
                        f"{tracing}{tree_path}: child_dict: Got {type(child_dict)}, not dict")
                    print(error_message)
                    assert False, error_message

                child_keys: Tuple[str, ...] = tuple(child_dict.keys())
                if "Label" not in child_dict:
                    error_message = (
                        f"{tracing}{tree_path}: child: 'Label' not one of {child_keys}")
                    print(error_message)
                    assert False, error_message
                child_name: str = child_dict["Label"]

                child_tree_path: Tuple[str, ...] = tree_path + (child_name,)
                self.node_process(child_tree_path, child_dict, group,
                                  indent=next_indent, tracing=next_tracing)

        if tracing:
            print(f"{tracing}<=FabCQtoFC.child_process({tree_path}, '{indent}')")


# main():
def main() -> None:
    """The main program."""
    environ = cast(Dict[str, str], os.environ)
    json_file_name: str = environ["JSON"] if "JSON" in environ else "/tmp/TestProject.json"
    cnc: bool = "CNC" in environ
    json_reader: FabCQtoFC = FabCQtoFC(Path(json_file_name), cnc)
    json_reader.process(indent="", tracing="")
    if not App.GuiUp:  # type: ignore
        sys.exit()


if __name__ == "__main__":
    main()
