#!/usr/bin/env python3
"""CQtoFC: A module for reading CadQuery generated STEP files into FreeCAD.

This shell script converts the JSON file (.json) and associated STEP (.stp) files generated by
Fab Project into FreeCAD document files (.FCStd) and optionally it can generate CNC G code (.nc)
files.

This program is meant to be run by the FreeCAD Python interpreter.  Since there is no easy
way to pass command line arguments the interpreter, there is a shell file called `cq2fc.sh`
sets everything up to run in FreeCAD.  It passes arguments/optons in via Environment variables.
(Crude, but effective.)

The environment variable that are read are:

JSON: This the path to the JSON file.
CNC: If this is present, CNC G code (.nc) files are generated.

"""

# <--------------------------------------- 100 characters ---------------------------------------> #

from dataclasses import dataclass, field
import json
import os
from pathlib import Path
import sys
from typing import Any, cast, List, Dict, IO, Tuple

# Freecad has two different importers depending upon whether it is GUI mode or not.
from FreeCAD import Vector  # type: ignore
if App.GuiUp:  # type: ignore
    from FreeCAD import ImportGui as FCImport  # type: ignore
else:
    from FreeCAD import Import as FCImport  # type ignore


# FabCQtoFC:
@dataclass
class FabCQtoFC(object):
    """FabCQtoFC: Import CadQuery .step files into FreeCAD."""

    json_path: Path
    cnc: bool
    steps_document: Any = field(init=False, repr=False)
    project_document: Any = field(init=False, repr=False)
    all_documents: List[Any] = field(init=False, repr=False)
    pending_links: List[Tuple[Any, Any]] = field(init=False, repr=False)

    # FabCQtoFC.__post_init__():
    def __post_init__(self) -> None:
        """Initialize FabCQtoFC."""
        assert isinstance(self.json_path, Path), self.json_path
        self.steps_document = None
        self.all_documents = []
        self.pending_links = []
        self.pending_links: List[Tuple[Any, Any]] = []
        self.project_document = None

    # FabCQtoFC.process():
    def process(self, indent: str = "", tracing: str = "") -> None:
        """Process a JSON file into a FreeCAD documents."""
        next_tracing: str = tracing + "  " if tracing else ""
        if tracing:
            print(f"{tracing}=>FabCQtFC.process({str(self.json_path), {self.cnc}})")

        # Create the *steps_document*:
        json_directory: Path = self.json_path.parent
        steps_document: Any = App.newDocument("Step_Files")  # type: ignore
        self.steps_document = steps_document
        self.all_documents.append(steps_document)

        # Read in *json_path*:
        json_file: IO[str]
        json_text: str = ""
        if self.json_path.suffix != ".json":
            raise RuntimeError(f"JSON file must have `.json` suffix: '{str(self.json_path)}'")
        if tracing:
            print(f"{tracing}Loading {str(self.json_path)}")
        with open(self.json_path, "r") as json_file:
            json_text = json_file.read()
        if tracing:
            print(f"{tracing}Parsing {str(self.json_path)}")
        json_root = cast(Dict[str, Any], json.loads(json_text))
        assert isinstance(json_root, dict), json_root

        # Recursively walk the tree starting at *json_root*:
        if tracing:
            print(f"{tracing}Processing {str(self.json_path)}")
        self.node_process(("Root",), json_root, group=None, indent=indent, tracing=next_tracing)

        # Save *all_documents*:
        document: Any
        for document in self.all_documents:
            save_path: Path = json_directory / f"{document.Label}.FCStd"
            if save_path.exists():
                save_path.unlink()
            document.saveAs(str(save_path))

        # Install all of the *pending_links*:
        pending_link: Tuple[Any, Any]
        link: Any
        part: Any
        for link, part in self.pending_links:
            link.setLink(part)
        if tracing:
            print(f"{tracing}<=FabCQtFC.process({str(self.json_path), {self.cnc}})")

    # FabCQtoFC.node_process():
    def node_process(self, tree_path: Tuple[str, ...], json_dict: Dict[str, Any], group: Any,
                     indent: str = "", tracing: str = "") -> None:
        """Process one 'node' of JSON content."""

        def type_verify(value: Any, value_type: type,
                        tree_path: Tuple[str, ...], tag: str) -> None:
            """Verify JSON type."""
            if not isinstance(value, value_type):
                message: str = f"{tree_path}: {tag}: Got {type(value)}, not {value_type}"
                print(message)
                assert False, message

        def key_verify(key: str, table: Dict[str, Any], key_type: type,
                       tree_path: Tuple[str, ...], tag: str) -> Any:
            """Verify key is in dictionary and has correct type."""
            if key not in table:
                message: str = f"{tree_path}: {tag}: 'key' is not one of {tuple(table.keys())}'"
                print(message)
                assert False, message
            value: Any = table[key]
            type_verify(value, key_type, tree_path, tag)
            return value

        # Set up *tracing* and pretty print *indent*:
        next_tracing: str = tracing + "  " if tracing else ""
        next_indent = indent + "  " if indent else ""
        if tracing:
            print(f"{tracing}=>FabCQtoFC.child_process(*, {tree_path}, '{indent}')")
            print(f"{tracing}{json_dict=}")

        # Do some sanity checking:
        error_message: str
        type_verify(json_dict, dict, tree_path, "json_dict")
        kind = cast(str, key_verify("Kind", json_dict, str, tree_path, "Kind"))
        label = cast(str, key_verify("Label", json_dict, str, tree_path, "Label"))
        if indent:
            print(f"{indent}{label}:")
            print(f"{indent} Kind: {kind}")

        # Verify that that *kind* is one of the *allowed_kinds*:
        allowed_kinds: Tuple[str, ...] = (
            "Project", "Document", "Assembly", "Solid", "Mount",
            "Extrude", "Pocket", "Drill")
        if kind not in allowed_kinds:
            error_message = f"{tree_path}: Node kind '{kind}' not one of {allowed_kinds}"
            print(error_message)
            assert False, error_message

        steps_document: Any = self.steps_document
        project_document: Any = self.project_document

        # Dispatch on *kind*:
        if kind == "Project":
            pass
        elif kind == "Document":
            project_document = App.newDocument(label)  # type: ignore
            project_document.Label = label
            file_path: str = cast(str, key_verify(
                "_FilePath", json_dict, str, tree_path, "Document._File_Path"))
            if indent:
                print(f"{indent} _FilePath: {file_path}")
            self.project_document = project_document
            self.all_documents.append(project_document)
        elif kind == "Assembly":
            if group:
                group = group.newObject("App::DocumentObjectGroup", label)
            else:
                group = project_document.addObject("App::DocumentObjectGroup", label)
        elif kind == "Solid":
            step: str = cast(str, key_verify("_Step", json_dict, str, tree_path, "Solid._step"))
            if indent:
                print(f"{indent} _Step: {step}")
            before_size: int = len(steps_document.RootObjects)
            FCImport.insert(step, steps_document.Label)
            after_size: int = len(steps_document.RootObjects)
            assert before_size + 1 == after_size, (before_size, after_size)
            part: Any = steps_document.getObject(label)
            part.Label = f"{label}_Step"
            steps_document.RootObjects[before_size].Label = label

            # Install *link* into *group*.  Complete the link later on using *pending_links*:
            link: Any = group.newObject("App::Link", label)
            self.pending_links.append((link, part))
        elif kind == "Mount":
            contact_list: List[float] = cast(
                list, key_verify("_Contact", json_dict, list, tree_path, "Solid._Contact"))
            normal_list: List[float] = cast(
                list, key_verify("_Normal", json_dict, list, tree_path, "Solid._Normal"))
            orient_list: List[float] = cast(
                list, key_verify("_Orient", json_dict, list, tree_path, "Solid._Orient"))
            contact: Vector = Vector(contact_list)
            normal: Vector = Vector(normal_list)
            orient: Vector = Vector(orient_list)
            if indent:
                print(f"{indent} _Contact: {contact}")
                print(f"{indent} _Normal: {normal}")
                print(f"{indent} _Orient: {orient}")
        elif kind == "Extrude":
            depth = cast(float, key_verify("_Depth", json_dict, float, tree_path, "Extrude._Depth"))
            step = cast(str, key_verify("_Step", json_dict, str, tree_path, "Extrude._Step"))
            if indent:
                print(f"{indent} _Depth: {depth}")
                print(f"{indent} _Step: {step}")
        elif kind == "Pocket":
            depth = cast(float, key_verify("_Depth", json_dict, float, tree_path, "Extrude._Depth"))
            step = cast(str, key_verify("_Step", json_dict, str, tree_path, "Pocket._Step"))
            if indent:
                print(f"{indent} _Depth: {depth}")
                print(f"{indent} _Step: {step}")
        else:
            message = f"{kind} not one of {allowed_kinds}"
            print(message)
            assert False, message

        self.group = group

        if "children" in json_dict:
            children = cast(List[Dict[str, Any]],
                            key_verify("children", json_dict, list, tree_path, "Children"))
            if indent:
                print(f"{indent} children ({len(children)}):")

            child_dict: Dict[str, Any]
            for child_dict in children:
                type_verify(child_dict, dict, tree_path, "Child")
                child_name = cast(str, key_verify("Label", child_dict, str, tree_path, "Label"))
                child_tree_path: Tuple[str, ...] = tree_path + (child_name,)
                self.node_process(child_tree_path, child_dict, group,
                                  indent=next_indent, tracing=next_tracing)

        if tracing:
            print(f"{tracing}<=FabCQtoFC.child_process({tree_path}, '{indent}')")


# main():
def main() -> None:
    """The main program."""
    environ = cast(Dict[str, str], os.environ)
    json_file_name: str = environ["JSON"] if "JSON" in environ else "/tmp/TestProject.json"
    cnc: bool = "CNC" in environ
    json_reader: FabCQtoFC = FabCQtoFC(Path(json_file_name), cnc)
    json_reader.process(indent="  ", tracing="")
    if not App.GuiUp:  # type: ignore
        sys.exit()


if __name__ == "__main__":
    main()
